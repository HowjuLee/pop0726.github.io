<html>
<head>
<title>数据结构</title>
<meta http-equiv="Content-Type" content="text/html; charset="utf-8"">
<link rel="stylesheet" href="../../../css/style.css" type="text/css">
</head>

<body text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0" bgcolor="#4A5594">
<table width="100%" border="0" cellspacing="0" cellpadding="0" height="100%">
  <tr> 
    <td width="8">&nbsp;</td>
    <td class="white" valign="top"><span class="part">　1.3.3 算法效率的衡量方法</span><br>
      <br>
      　　又如何估算算法的时间复杂度呢？<br>
      <br>
      　　任何一个算法都是由一个&quot;控制结构&quot;和若干&quot;<b>原操作</b>&quot;组成的，因此一个算法的执行时间可以看成是所有原操作的执行时间之和<br>
      　　　∑( 原操作(i)的执行次数 <img src="../../../images/pic/chapter04/t5.gif" width="7" height="7"> 
      原操作(i)的执行时间 )<br>
      <br>
      　　则算法的执行时间与所有原操作的执行次数之和成正比。<br>
      <br>
      　　从算法中选取一种对于所研究的问题来说是<span class="point">基本操作</span>的原操作，以该基本操作在算法中重复执行的次数作为算法时间复杂度的依据。这种衡量效率的办法所得出的不是时间量，而是一种增长趋势的量度。它与软硬件环境无关，只暴露算法本身执行效率的优劣。下面举三个例子介绍时间复杂度的估算方法。</td>
    <td background="../../../images/html/mid.gif" width="18">&nbsp;</td>
    <td background="../../../images/html/right_di4.gif" class="explaination" width="281" valign="top"><br>
      　<br>
      　<br>
      　　&quot;原操作&quot;指的是固有数据类型的操作，显然每个原操作的执行时间和算法无关，相对于问题的规模是常量。同时由于算法的时间复杂度只是算法执行时间增长率的量度，因此只需要考虑在算法中&quot;起主要作用&quot;的原操作即可，称这种原操作为&quot;基本操作&quot;，它的重复执行次数和算法的执行时间成正比。</td>
    <td background="../../../images/html/right_di3.gif" width="13">&nbsp;</td>
  </tr>
</table>
</body>
</html>
