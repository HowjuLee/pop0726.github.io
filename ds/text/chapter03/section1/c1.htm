<html>
<head>
<title>数据结构</title>
<meta http-equiv="Content-Type" content="text/html; charset="utf-8"">
<link rel="stylesheet" href="../../../css/style.css" type="text/css">
</head>

<body text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0" bgcolor="#4A5594">
<table width="100%" border="0" cellspacing="0" cellpadding="0" height="100%">
  <tr> 
    <td width="8">&nbsp;</td>
    <td class="white" valign="top">
      <span class="part">　3.1.1 栈的类型定义</span><br>
        <br>
        　　<span class="part">栈（Stack）</span>是限定只能在表的一端进行插入和删除操作的线性表。在表中，允许插入和删除的一端称作&quot;<span class="point">栈顶</span>(top)&quot;，不允许插入和删除的另一端称作&quot;<span class="point">栈底</span>(bottom)&quot; 
        。 <br>
        <br>
        　 <div align="center"><img src="../../../images/pic/chapter03/3_1.gif" width="189" height="94" align="top"></div><br>
        <br>
        　其类型定义如下：<br>
        <b><br>
        ADT Stack {</b><br>
        　<span class="zhushi">数据对象：</span>D＝{ <img src="../../../images/pic/chapter02/gs/ai.gif" width="10" height="10"> 
        | <img src="../../../images/pic/chapter02/gs/ai.gif" width="10" height="10">∈ElemSet, 
        i=1,2,...,n, n≥0 }<br>
        <br>
        　<span class="zhushi">数据关系：</span>R<font size="1">1</font>＝{ &lt; <img src="../../../images/pic/chapter02/gs/ai_1.gif" width="20" height="10">, 
        <img src="../../../images/pic/chapter02/gs/ai.gif" width="10" height="10"> 
        &gt;| <img src="../../../images/pic/chapter02/gs/ai_1.gif" width="20" height="10">, 
        <img src="../../../images/pic/chapter02/gs/ai.gif" width="10" height="10">∈D, 
        i=2,...,n }<br>
        　　　　　　　　　约定 <img src="../../../images/pic/chapter02/gs/an.gif" width="12" height="10"> 
        端为栈顶，<img src="../../../images/pic/chapter02/gs/a1.gif" width="11" height="10"> 
        端为栈底。<br>
        　<span class="zhushi">基本操作：</span><br>
        　　InitStack(<b><font face="Times New Roman, Times, serif">&amp;</font></b>S)<br>
      　　　操作结果：构造一个空栈 S。<br>
        <br>
        　　DestroyStack(<b><font face="Times New Roman, Times, serif">&amp;</font></b>S)<br>
      　　　初始条件：栈 S 已存在。<br>
      　　　操作结果：栈 S 被销毁。 <br>
        <br>
        　　ClearStack(<b><font face="Times New Roman, Times, serif">&amp;</font></b>S)<br>
      　　　初始条件：栈 S 已存在。<br>
      　　　操作结果：将 S 清为空栈。<br>
        　
    </td>
    <td background="../../../images/html/mid.gif" width="18">&nbsp;</td>
    <td background="../../../images/html/right_di4.gif" class="explaination" width="281" valign="top"><br>
      <br>
      　　通常称往栈顶插入元素的操作为&quot;入栈&quot;，称删除栈顶元素的操作为&quot;出栈&quot;。因为后入栈的元素先于先入栈的元素出栈，故被称为是一种&quot;后进先出&quot;的结构，因此又称LIFO（LastIn 
      First Out的缩写）表。很多书上都以如下图所示的铁路调度站形象地表示栈的这个特点。<br>
      <br>
      　　　<img src="../../../images/pic/chapter03/3_1_1_2.gif" width="175" height="172" align="top"><br>
    </td>
    <td background="../../../images/html/right_di3.gif" width="13">&nbsp;</td>
  </tr>
  <tr>
    <td width="8">&nbsp;</td>
    <td class="white" valign="top"> 　　StackEmpty(S)<br>
      　　　初始条件：栈 S 已存在。<br>
      　　　操作结果：若栈 S 为空栈，则返回TRUE，否则返回FALSE。<br>
      <br>
      　　StackLength(S)<br>
      　　　初始条件：栈 S 已存在。<br>
      　　　操作结果：返回栈 S 中元素个数，即栈的长度。<br>
      　</td>
    <td background="../../../images/html/mid.gif" width="18">&nbsp;</td>
    <td background="../../../images/html/right_di4.gif" class="explaination" width="281" valign="top">　　判定栈是否为空栈是栈在应用程序中经常使用的操作，通常以它作为循环结束的条件。</td>
    <td background="../../../images/html/right_di3.gif" width="13">&nbsp;</td>
  </tr>
  <tr>
    <td width="8">&nbsp;</td>
    <td class="white" valign="top">　　GetTop(S, <b><font face="Times New Roman, Times, serif">&amp;</font></b>e)<br>
      　　　初始条件：栈 S 已存在且非空。<br>
      　　　操作结果：用 e 返回S的栈顶元素。<br>
      <br>
      　　Push(<b><font face="Times New Roman, Times, serif">&amp;</font></b>S, e)<br>
      　　　初始条件：栈 S 已存在。<br>
      　　　操作结果：插入元素 e 为新的栈顶元素。<br>
      　</td>
    <td background="../../../images/html/mid.gif" width="18">&nbsp;</td>
    <td background="../../../images/html/right_di4.gif" class="explaination" width="281" valign="top">　　这是取栈顶元素的操作，只以 
      e 返回栈顶元素，并不将它从栈中删除。 <br>
      <br>
      <br>
      　　这是入栈操作，在当前的栈顶元素之后插入新的栈顶元素。</td>
    <td background="../../../images/html/right_di3.gif" width="13">&nbsp;</td>
  </tr>
  <tr>
    <td width="8">&nbsp;</td>
    <td class="white" valign="top">　　Pop(<b><font face="Times New Roman, Times, serif">&amp;</font></b>S, <b><font face="Times New Roman, Times, serif">&amp;</font></b>e)<br>
      　　　初始条件：栈 S 已存在且非空。<br>
      　　　操作结果：删除 S 的栈顶元素，并用 e 返回其值。<br>
      <br>
      　　StackTraverse(S, visit( ))<br>
      　　　初始条件：栈 S 已存在且非空，visit( )为元素的访问函数。<br>
      　　　操作结果：从栈底到栈顶依次对S的每个元素调用函数visit( )，<br>
      　　　　　　　　一旦visit( )失败，则操作失败。<br>
      <br>
      <b>} ADT Stack</b></td>
    <td background="../../../images/html/mid.gif" width="18">&nbsp;</td>
    <td background="../../../images/html/right_di4.gif" class="explaination" width="281" valign="top">　　这是出栈操作，不仅以 
      e 返回栈顶元素，并将它从栈中删除。<br>
      <br>
      <br>
      　　这是对栈进行从栈底到栈顶的&quot;遍历&quot;操作，应用较多的场合是，输出栈中所有数据元素。 
      <p>　　栈的基本操作集和线性表相比要小的多，但它们在应用程序中都能用到。</p>
    </td>
    <td background="../../../images/html/right_di3.gif" width="13">&nbsp;</td>
  </tr>
</table>
</body>
</html>
