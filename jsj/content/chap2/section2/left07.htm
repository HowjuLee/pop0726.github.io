<html>
<head>
<title>计算机系统结构</title>
<meta http-equiv="Content-Type" content="text/html; charset="utf-8"">

<link rel="stylesheet" href="../../../css/text.css" type="text/css">
<link rel="stylesheet" href="../../../css/text01.css" type="text/css">
</head>

<body text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0" bgcolor="#FFFFFF">
<div align="center">
  <table width="96%" border="0" cellspacing="3" cellpadding="2" height="100%">
    <tr>
      <td valign="top" height="37"> 
        <table width="40%" border="0" cellspacing="0" cellpadding="0" background="../../../images/bg0401.gif" height="18" align="right">
          <tr>
            <td class="pt10"> 
              <div align="center" class="title">第二章 指令系统</div>
            </td>
          </tr>
        </table>
      </td>
    </tr>
    <tr>
      <td valign="top" height="119"> 
        <div align="center"> 
          <p align="left"><span class="pt9-black"><br>
            <b>　　比较以上两个程序，可以很明显地看出，采用变址寻址方式编写的程序简单、易读。对程序员来说，两种寻址方式的主要差别如下：</b><br>
            　　间址寻址方式：间接地址在主存储器中，没有偏移量。<br>
            　　变址寻址方式：基地址在变址寄存器中，带有偏移量。<br>
            <br>
            <b>　　由此产生的两种寻址方式的优点与缺点是：</b><br>
            <br>
            　　(1)实现的难易程度，间址寻址方式实现起来很容易，只需要增加一条从主存储器的数据寄存器到地址寄存器的数据通路即可。实现变址寻址方式需要增加较多的硬件，需要一个硬件的加法器，一个或多个变址寄存器（也可以与通用寄存器合用）。<br>
            　　(2)指令的执行速度，采用间址寻址方式编写的程序，执行速度很慢。读写一个操作数至少需要访问两次主存储器，第一次访问主存储器读取有效地址，第二次访问主存储器是读或写操作数，如果采用多次间址寻址方式，则访问主存储器的次数还要增多。例如执行上述程序中的MOVE 
            @ASI, @ADI这条指令，至少需要访问主存储器5次，其中，第一次访问主存储器，读取指令本身，第二。第三次访问主存储器读到源操作数，再经过两次访问主存储器操作，才能把数据送入主存储器的目标地址单元中。采用变址寻址方式编写的程序，执行速度比较快。有效地址通过硬件加法器直接产生，不需要访问主存储器。如执行上述程序中的MOVE 
            (X), AD-AS(X) 这条指令，只需要访问主存储器3次。<br>
            　　(3)对数组运算的支持，变址寻址方式比较好，间址寻址方式较差，这是因为变址寻址方式可以带有偏移量。基地址加偏移量能够很有效地表示向量、矩阵等数据。<br>
            <b><br>
            　　另外，对于变址寻址方式和间址寻址方式，还有以下几个问题需要注意：</b><br>
            　　(1)变址寻址方式中的偏移量是带有符号的，通常用补码表示，这样，不仅可以有向前的偏移，也可以有向后的偏移。偏移量的长度一般短于基地址的长度，在做加法时，一定要把偏移量的符号扩展，直至与基地址的长度相同。例如，某机器的偏移量为二进制8位，有一个用16进制补码表示的偏移量F3，基地址为二进制16位，有一个用16进制表示的基地址05CD，正确的做法是：在做加法之前，首先要把偏移量的符号扩展8个二进位，成为FFFD，再与基地址相加，结果的有效地址是：05CD＋FFF3＝05C00。<br>
            　　(2)自动变址。从上面的例子中看到，无论采用间接寻址方式，还是采用变址寻址方式编写程序，对于数组运算，都必须有对地址进行增量的指令。在采用间接寻址方式编写的程序中，有两条指令分别对源数组和目标数组的地址指针进行增量，在采用变址寻址方式编写的程序中，有一条指令对变址寄存器进行增量。为了省去这些对地址进行增量的指令，在许多机器中对于间接寻址方式和变址寻址方式都增加了自动变址的功能。<br>
            　　上例中，对于采用间接寻址方式编写的程序，只要把指令：MOVE @AS, @AD 改为: MOVE (AS)+,(AD)+，紧接在下面的两条分别对ASI和ADI指针作增量的指令就可以省去。同样，在采用变址寻址方式编写的程序中，把指令：MOVE 
            (X), AD-AS(X) 改为：MOVE (X), AD-AS(X)+，紧接在下面的一条对变址寄存器作增量的指令就可以省去。<br>
            　　地址增量的单位，要根据具体机器所采用的编址方式和数据元素的长度等关系来确定，例如，对于采用字节编址的机器，如果数据元素的长度是二进制16位，则增量单位是2，如果数据元素的长度是二进制32位，则增量单位是4。<br>
            　　地址增量的先后关系也很有讲究，有如下几种方式： <br>
            　　第一种，先用后增与先减后用方式，程序中的写法是：(X)+，-(X)。这种方式多用于有后进先出堆栈，而且堆栈指针指向栈顶元素的机器中。<br>
            　　第二种，先增后用与先用后减方式：程序中的写法是：+(X)，(X)-。这种方式多用于有后进先出堆栈，而且堆栈指针指向栈顶第一个空元素的机器中。<br>
            　　第三种，先增后用与先减后用方式：程序中的写法是：+(X)，-(X)。这种方式多用于有没有后进先出堆栈的机器中。<br>
            　　(3)前变址与后变址。在既有变址寻址方式，又有间址寻址方式的计算机系统中，先做变址运算还是先做间址运算，需要事先定义。在指令中给出一个变址寄存器编号X和一个相对地址A。有效地址EA的计算方法有如下两种：<br>
            　　第一种，前变址寻址方式，有效地址的计算过程是：EA＝((X)＋A)。<br>
            　　第二种，后变址寻址方式，有效地址的计算过程是：EA＝(X)＋(A)。<br>
            </span></p>
          <p align="left"><span class="pt9-black">　</span></p>
        </div>
      </td>
    </tr>
  </table>
</div>
</body>
</html>
