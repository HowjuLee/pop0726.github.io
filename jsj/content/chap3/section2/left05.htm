<html>
<head>
<title>计算机系统结构</title>
<meta http-equiv="Content-Type" content="text/html; charset="utf-8"">

<link rel="stylesheet" href="../../../css/text.css" type="text/css">
<link rel="stylesheet" href="../../../css/text01.css" type="text/css">
</head>

<body text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0" bgcolor="#FFFFFF">
<div align="center">
  <table width="96%" border="0" cellspacing="3" cellpadding="2" height="100%">
    <tr>
      <td valign="top" height="37"> 
        <table width="40%" border="0" cellspacing="0" cellpadding="0" background="../../../images/bg0401.gif" height="18" align="right">
          <tr>
            <td class="pt10"> 
              <div align="center" class="title">第三章 存储系统</div>
            </td>
          </tr>
        </table>
      </td>
    </tr>
    <tr>
      <td valign="top" height="119"> 
        <div align="center"> 
          <p align="left"><span class="pt9-black">　　根据需要还可以在段表中增加其它字段，例如，增加一个修改标志字段，表示本程序段是否被修改过，如果这个程序段从装入主存储器起一直没有被修改过，则在需要把它替换出主存储器时，不必把它写回到外部的磁盘存储器中，只要用新调入的程序段把它覆盖掉即可。如果这个程序段被修改过，则必须先把这个程序段全部写回到磁盘存储器中存放这个程序段的原来位置上。<br>
            　　段表本身也是一个段，一般常驻在主存储器中。如果段表太长，也可以把暂时不用的一部分段表放在磁盘存储器中，当需要时再把有用的段表调入主存储器。<br>
            <br>
            <b>　　段式虚拟存储器的主要优点如下：</b><br>
            <br>
            　　1、程序的模块化性能好。对于大程序，可以划分成多个程序段，每个程序段赋予不同的名字，由多个程序员并行编写，分别编译和调试。由于各个程序段在功能上是相互独立的，因此，一个程序段的修改和增删等不会影响其它程序段，从而可以缩短程序的编制和调试所用的时间。 
            <br>
            　　2、便于程序和数据的共享。由于程序段是按功能来划分的，如子程序段、数组段、表格段等，每个程序段有比较完整的功能，因此，被共享的可能性很大。当某个程序段需要共享时，只要在主存储器中装入一份，同时在需要调用这个程序段的那些程序（或用户）的段表中都使用这个程序段的主存起始地址和段长等信息，就能很方便地实现程序段的共享。<br>
            　　3、程序的动态链接和调度比较容易。由于每一个程序段都是一组有独立意义的数据块或具有完整功能的程序段，因此，在程序运行过程中，可以根据需要一次就把一个程序段或数据块都装入到主存储器中，并且可以在装入时才实行动态链接。<br>
            　　4、便于实现信息保护。在一般情况下，一段程序是否需要保护是根据这个段程序的功能来决定的。例如，一般的数据段能读能写，常数段只能读不能写，所有的数据段都不允许执行，而子程序一般只能执行不能修改等。由于段式虚拟存储器本身就是按照功能划分程序段的，因此，只要在段表中设置一个信息保护字段，就能根据需要很方便地实现对该程序段的保护。<br>
            <br>
            　　<b>段式虚拟存储器的主要缺点是：<br>
            </b><br>
            　　1、地址变换所花费的时间比较长。从图3.15中看到，从多用户虚地址变换到主存实地址需要查两次表，做两次加法运算。<br>
            　　2、主存储器的利用率往往比较低。由于每个程序段的长度是不同的，一个程序段通常要装在一个连续的主存空间中，程序段在主存储器中不断地调入调出，有些程序段在执行过程中还要动态增加长度，从而使得主存储器中有很多的空隙存在。当然，也可以采用一些好的算法来减少空隙的数量，或者通过定时运行回收程序来合并这些空隙，但无疑增加了系统的开销。<br>
            　　3、对辅存（磁盘存储器）的管理比较困难。磁盘存储器通常是按固定大小的块来访问的，如何把不定长度的程序段映象到固定长度的磁盘存储器中，需要做一次地址变换。 
            <br>
            <br>
            </span></p>
        </div>
      </td>
    </tr>
  </table>
</div>
</body>
</html>
