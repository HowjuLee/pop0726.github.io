<html>
<head>
<title>计算机系统结构</title>
<meta http-equiv="Content-Type" content="text/html; charset="utf-8"">

<link rel="stylesheet" href="../../../css/text.css" type="text/css">
<link rel="stylesheet" href="../../../css/text01.css" type="text/css">
</head>

<body text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0" bgcolor="#FFFFFF">
<div align="center">
  <table width="96%" border="0" cellspacing="3" cellpadding="2" height="100%">
    <tr>
      <td valign="top" height="37"> 
        <table width="40%" border="0" cellspacing="0" cellpadding="0" background="../../../images/bg0401.gif" height="18" align="right">
          <tr>
            <td class="pt10"> 
              <div align="center" class="title">第三章 存储系统</div>
            </td>
          </tr>
        </table>
      </td>
    </tr>
    <tr>
      <td valign="top" height="119"> 
        <div align="center"> 
          <p align="left"><b><span class="part">3.2.7 页面替换算法</span></b><span class="pt9-black"><b><br>
            <br>
            </b>　　在虚拟存储器中，当发生页面失效时，需要从磁盘存储器中调入一页（或一段）到主存储器中。在段式和段页式虚拟存储器中，由于多用户虚页数比主存储器的实页数要多得多。在段式虚拟存储器中，虚存空间中能容纳的程序段数要比主存空间中能存放的相同长度的程序段数多得多。因此，必然会出现当主存中所有页面都已经被占用，或者所有主存空间都已经被占用，而又要从磁盘存储器中调入新页的情况。这时，必须从主存储器中淘汰掉一个不常用的页面，以便腾出主存空间来存放新调入的页面。那么，按照什么样的规则替换主存储器中的页面呢？这就是页面替换算法要解决的问题。<br>
            　　以下，为了叙述方便，主要介绍页式和段页式虚拟存储器中的页面替换算法及其实现方法，在这两种虚拟存储器中都是以页面为单位进行调度的。而段式虚拟存储器是以程序段为单位进行调度的，但是它所采用的替换算法及算法的实现方法都是相同的。<br>
            　　评价一个页面替换算法好坏的标准主要有两个，一是命中率要高，二是算法要容易实现。要提高一个页面替换算法的命中率，首先要使这种算法能正确反映程序的局部性，其次是这种算法要能够充分利用主存中页面调度情况的历史信息，或者能够预测主存中将要发生的页面调度情况。<br>
            　　页面替换算法的用处有如下几个地方：<br>
            　　1、虚拟存储器中，主存页面（或程序段）的替换。<br>
            　　2、Cache中的块替换。<br>
            　　3、虚拟存储器的快慢表中，快表的替换。<br>
            　　4、虚拟存储器中，用户基地址寄存器的替换。<br>
            <br>
            　　<b>在虚拟存储器中常用的页面替换算法有如下几种：</b><br>
            <br>
            　　1、随机算法，即RAND算法（Random algorithm）。利用软件或硬件的随机数发生器来确定主存储器中被替换的页面。这种算法最简单，而且容易实现。但是，这种算法完全没有利用主存储器中页面调度情况的历史信息，也没有反映程序的局部性，所以命中率比较低。<br>
            　　2、先进先出算法，即FIFO算法（First-In First-Out algorithm）。这种算法选择最先调入主存储器的页面作为被替换的页面。它的优点是比较容易实现，能够利用主存储器中页面调度情况的历史信息，但是，没有反映程序的局部性。因为最先调入主存的页面，很可能也是经常要使用的页面。 
            <br>
            　　3、近期最少使用算法，即LFU算法（Least Frequently Used algorithm）。这种算法选择近期最少访问的页面作为被替换的页面。显然，这是一种非常合理的算法，因为到目前为止最少使用的页面，很可能也是将来最少访问的页面。该算法既充分利用了主存中页面调度情况的历史信息，又正确反映了程序的局部性。但是，这种算法实现起来非常困难，它要为每个页面设置一个很长的计数器，并且要选择一个固定的时钟为每个计数器定时计数。在选择被替换页面时，要从所有计数器中找出一个计数值最大的计数器。因此，通常采用如下一种相对比较简单的方法。<br>
            　　4、最久没有使用算法，即LRU算法（Least Recently Used algorithm）。这种算法把近期最久没有被访问过的页面作为被替换的页面。它把LFU算法中要记录数量上的&quot;多&quot;与&quot;少&quot;简化成判断&quot;有&quot;与&quot;无&quot;，因此，实现起来比较容易。<br>
            　　5、最优替换算法，即OPT算法（OPTimal replacemant algorithm）。上面介绍的几种页面替换算法主要是以主存储器中页面调度情况的历史信息为依据的，它假设将来主存储器中的页面调度情况与过去一段时间内主存储器中的页面调度情况是相同的。显然，这种假设不总是正确的。最好的算法应该是选择将来最久不被访问的页面作为被替换的页面，这种替换算法的命中率一定是最高的，它就是最优替换算法。 
            <br>
            　　要实现OPT算法，唯一的办法是让程序先执行一遍，记录下实际的页地址流情况。根据这个页地址流才能找出当前要被替换的页面。显然，这样做是不现实的。因此，OPT算法只是一种理想化的算法，然而，它也是一种很有用的算法。实际上，经常把这种算法用来作为评价其它页面替换算法好坏的标准。在其它条件相同的情况下，哪一种页面替换算法的命中率与OPT算法最接近，那么，它就是一种比较好的页面替换算法。<b><br>
            <br>
            </b></span></p>
        </div>
      </td>
    </tr>
  </table>
</div>
</body>
</html>
