<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset="utf-8"">
<link rel="stylesheet" href="../../css/text.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#000000" leftmargin="10" topmargin="10">
<center>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td class=text> 
        
        <p><font color="#FF0000">第1题</font><br>
          　　答： 为了方便起见，我们用((AB)()())这样的表表示一个状态。这样得到搜索图如下： </p>
        <p><img src="../../images/t212.gif" width="346" height="426"></p>
        <p><br>
          <font color="#FF0000">第2题</font><br>
          　　提示：可定义h为：<br>
          h＝B右边的W的数目<br>
          设j节点是i节点的子节点，则根据走法不同，h(i)-h(j)的值和C(i, j)分为如下几种情况：<br>
          （1）B或W走到了相邻的一个空格位置，此时： h(i)-h(j)=0, C(i,j)=1；<br>
          （2）W跳过了1或2个W，此时 h(i)-h(j)=0, C(i,j)=1或2； <br>
          （3）W向右跳过了一个B（可能同时包含一个W），此时： h(i)-h(j)=-1, C(i,j)=1或2；<br>
          （4）W向右跳过了两个B，此时： h(i)-h(j)=-2, C(i,j)=2； <br>
          （5）W向左跳过了一个B（可能同时包含一个W），此时： h(i)-h(j)=1, C(i,j)=1或2； <br>
          （6）W向左跳过了两个B，此时： h(i)-h(j)=2, C(i,j)=2； <br>
          （7）B跳过了1或2个B，此时 h(i)-h(j)=0, C(i,j)=1或2； <br>
          （8）B向右跳过了一个W（可能同时包含一个B），此时： h(i)-h(j)=1, C(i,j)=1或2；<br>
          （9）B向右跳过了两个W，此时： h(i)-h(j)=2, C(i,j)=2；<br>
          （10）B向左跳过了一个W（可能同时包含一个B），此时： h(i)-h(j)=-1, C(i,j)=1或2； <br>
          （11）B向左跳过了两个W，此时： h(i)-h(j)=-2, C(i,j)=2；<br>
          纵上所述，无论是哪一种情况，具有:<br>
          h(i)-h(j)≤C(i,j)<br>
          且容易验证h(t)=0，所以该h是单调的。由于h满足单调条件，所以也一定有h(n)≤h*(n)，即满足A*条件。 <br>
          <br>
          <font color="#FF0000">第3题</font><br>
          　　答： 定义h1=n*k，其中n是还未走过的城市数，k是还未走过的城市间距离的最小值。 h2＝<img src="../../images/x1.gif" width="34" height="47" align="middle">，其中n是还未走过的城市数，k<sub>i</sub>是还未走过的城市间距离中n个最小的距离。 
          显然这两个h函数均满足A*条件。 <br>
          <br>
          <font color="#FF0000">第4题</font><br>
          　　提示：对于四皇后问题，如果放一个皇后的耗散值为1的话，则任何一个解的耗散值都是4。因此如果h是对该耗散值的估计，是没有意义的。对于像四皇后这样的问题，启发函数应该是对找到解的可能性的评价。比如像课上讲到的，利用一个位置放皇后后，消去的对角线的长度来进行评价。<br>
          <br>
          <font color="#FF0000">第5题</font><br>
          　　答： 定义h1=M+C-2B，其中M，C分别是在河的左岸的传教士人数和野人人数。B＝1表示船在左岸，B＝0表示船在右岸。<br>
          也可以定义h2=M+C。<br>
          h1是满足A*条件的，而h2不满足。<br>
          要说明h(n)＝M+C不满足A*条件是很容易的，只需要给出一个反例就可以了。比如状态(1, 1, 1)，h(n)=M+C=1+1=2，而实际上只要一次摆渡就可以达到目标状态，其最优路径的耗散值为1。所以不满足A*的条件。<br>
          下面我们来证明h(n)＝M+C-2B是满足A*条件的。<br>
          我们分两种情况考虑。先考虑船在左岸的情况。如果不考虑限制条件，也就是说，船一次可以将三人从左岸运到右岸，然后再有一个人将船送回来。这样，船一个来回可以运过河2人，而船仍然在左岸。而最后剩下的三个人，则可以一次将他们全部从左岸运到右岸。所以，在不考虑限制条件的情况下，也至少需要摆渡<img src="../../images/x2.gif" width="127" height="43" align="middle">次。其中分子上的"－3"表示剩下三个留待最后一次运过去。除以"2"是因为一个来回可以运过去2人，需要<img src="../../images/x3.gif" width="69" height="38" align="middle">个来回，而"来回"数不能是小数，需要向上取整，这个用符号<img src="../../images/x4.gif" width="21" height="22" align="middle">表示。而乘以"2"是因为一个来回相当于两次摆渡，所以要乘以2。而最后的"＋1"，则表示将剩下的3个运过去，需要一次摆渡。<br>
          化简有：</p>
        <p><img src="../../images/x5.gif" width="371" height="38"></p>
        <p> 再考虑船在右岸的情况。同样不考虑限制条件。船在右岸，需要一个人将船运到左岸。因此对于状态(M，C，0)来说，其所需要的最少摆渡数，相当于船在左岸时状态(M+1，C，1)或(M，C+1，1)所需要的最少摆渡数，再加上第一次将船从右岸送到左岸的一次摆渡数。因此所需要的最少摆渡数为：(M+C+1)-2+1 
          。其中(M+C+1)的"＋1"表示送船回到左岸的那个人，而最后边的"＋1"，表示送船到左岸时的一次摆渡。<br>
          化简有：(M+C+1)-2+1=M+C。<br>
          综合船在左岸和船在右岸两种情况下，所需要的最少摆渡次数用一个式子表示为：M+C-2B。其中B＝1表示船在左岸，B＝0表示船在右岸。 由于该摆渡次数是在不考虑限制条件下，推出的最少所需要的摆渡次数。因此，当有限制条件时，最优的摆渡次数只能大于等于该摆渡次数。所以该启发函数h是满足A*条件的。<br>
          <br>
          <font color="#FF0000">第6题</font><br>
          　　答：题目的另一个说法是：当A*结束时，OPEN表中任何一个具有f(n)&lt;f*(s)的节点都被扩展了。<br>
          用反证法证明。<br>
          假设在A*结束的时候，OPEN表中有一个节点n没有被扩展，且f(n)&lt;f*(s)。A*算法每次从OPEN表中取出f值最小的节点扩展，当该节点是目标节点时，算法结束。并且由可采纳性定理，知道这时A*找到了从初始节点到目标节点的最佳路径，即f(t)=f*(s)。如果这时OPEN中存在f(n)&lt;f*(s)的节点n，由于f(n)&lt;f(t)，则这时A*算法应选择n扩展，而不是目标t，与A*已经结束矛盾。<br>
          <br>
          <br>
          <font color="#FF0000">第7题</font><br>
          　　答： 因为A*选作扩展的任何一个节点n，均有f(n)≤f*(s)，因此f(n)&gt;f*(s)的节点，不会被A*所扩展。所以如果从OPEN表中去掉f(n)&gt;f*(s)的节点，不会影响A*的可采纳性。而F是f*(s)的上界范围，因此去掉f(n)&gt;F的节点也同样不会影响A*的可采纳性。<br>
          <br>
          <font color="#FF0000">第8题</font><br>
          　　提示：对于8数码问题，逆向搜索和正向搜索是完全一样的，只是把目标状态和初始状态对调就可以了。<br>
          <br>
          <font color="#FF0000">第9题</font><br>
          　　提示：在搜索期间改善h函数，是一种动态改变h函数的方法。像改进的A*算法中，对NEST中的节点按g值的大小选择待扩展的节点，相当于令这些节点的h＝0，就是动态修改h函数的一种方法。<br>
          由定理6，当h满足单调条件时，A*所扩展的节点序列，其f是非递减的。对于任何节点i，j，如果j是i的子节点，则有f(i)≤f(j)。利用该性质，我们可以提出另一种动态修改h函数的方法：<br>
          f(j)=max(f(i), f(j))<br>
          以f(j)作为节点j的f值。f值的改变，隐含了h值的改变。<br>
          当h不满足单调条件时，经过这样修正后的h具有一定的单调性质，可以减少重复节点的可能性。<br>
          <br>
          <br>
          <font color="#FF0000">第10题</font><br>
          　　提示：很多知识对求解问题有好处，这些知识并不一定要写成启发函数的形式，很多情况下，也不一定能清晰的写成一个函数的形式。</p>
        <p><img src="../../images/t2102.gif" width="221" height="214"></p>
        <p>　　为了叙述方便，我们将两个相对的扇区称为相对扇区，图中阴影部分的扇区称为阴影扇区，非阴影部分的扇区称为非阴影扇区。 由题意，在目标状态下，一个扇区的数字之和等于12，一个相对扇区的数字之和等于24，而一个阴影扇区或者非阴影扇区的数字之和为48。为此，我们可以将目标进行分解，首先满足阴影扇区的数字之和为48（这时非阴影部分的数字和也一定为48）。为了这个目标我们可以通过每次转动圆盘45<sup>o</sup>实现。在第一个目标被满足的情况下，我们再考虑第二个目标：每一个相对扇区的数字和为24。在实现这个目标的过程中，我们希望不破坏第一个目标。为此我们采用转动90<sup>o</sup>的方式实现，这样即可以调整相对扇区的数字和，又不破坏第一个目标。在第二个目标实现之后，我们就可以实现最终目标：扇区内的数字和为12。同样我们希望在实现这个目标的时候，不破坏前两个目标。为此我们采用转动180<sup>o</sup>的方式实现。这样同样是即可以保证前两个目标不被破坏，又可以实现第三个目标。 
          经过这样的分析以后，我们发现该问题就清晰多了。当然，是否每一个第一、第二个目标的实现，都能够实现第三个目标呢？有可能不一定。在这种情况下，就需要在发现第三个目标不能实现时，重新试探其他的第一、第二个目标。 
          <br>
          　</p>
      </td>
  </tr>
</table>
  </center>

</body>
</html>
