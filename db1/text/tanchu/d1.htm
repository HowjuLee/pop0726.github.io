<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset="utf-8"">
<link href="../../css/text.css" rel="stylesheet" type="text/css">
</head>

<body background="../../image/tanchu/01.gif" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td><div align="center"> 
        <table border="1" cellpadding="0" cellspacing="0" bordercolor="#000000" class="explaination">
          <tr class="zhishidian"> 
            <td width="48" valign="top"> <p class="MsoNormal" align="center" style="text-align:center"><b><span style="font-family:宋体;Times New Roman&quot;">序号<span lang="EN-US"> 
                </span></span></b></p></td>
            <td width="144" valign="top"> <p class="MsoNormal" align="center" style="text-align:center"><b><span style="font-family:宋体;Times New Roman&quot;">问题<span lang="EN-US"> 
                </span></span></b></p></td>
            <td width="372" valign="top"> <p class="MsoNormal" align="center" style="text-align:center"><b><span style="font-family:宋体;Times New Roman&quot;">解答<span lang="EN-US"> 
                </span></span></b></p></td>
          </tr>
          <tr> 
            <td width="48" valign="middle"> <p class="MsoNormal" align="center" style="text-align:center"><b><span lang="EN-US" style="font-family:宋体;
  Times New Roman&quot;">1 </span></b></p></td>
            <td width="144" valign="top" class="section"> <p class="MsoNormal"><span style="font-family:宋体;Times New Roman&quot;">数据库与数据库系统一样吗？<span lang="EN-US"> 
                </span></span></p></td>
            <td width="372" valign="top"> <p class="text">数据库与数据库系统不一样。数据库是指相互关联的数据的集合，口语中的“数据库系统”一般强调的是“数据库管理系统”，即<span lang="EN-US">DBMS。真正的数据库系统是由数据库、数据库管理系统（DBMS）及其开发工具、数据库应用、数据库管理员和最终用户等构成的一个综合系统。 
                </span></p></td>
          </tr>
          <tr> 
            <td width="48" valign="middle"> <p class="MsoNormal" align="center" style="text-align:center"><b><span lang="EN-US" style="font-family:宋体;
  Times New Roman&quot;">2 </span></b></p></td>
            <td width="144" valign="top" class="section"> <p class="MsoNormal"><span style="font-family:宋体;Times New Roman&quot;">数据查询语言和数据操纵语言是一回事吗？<span lang="EN-US"> 
                </span></span></p></td>
            <td width="372" valign="top"> <p class="MsoNormal"><span class="text" style="font-family:宋体;Times New Roman&quot;;
  Times New Roman&quot;">数据操纵是指对存储在数据库中的信息进行检索、向数据库中插入新的信息、从数据库中删除信息以及修改存储在数据库中的信息。</span><span class="text" style="font-family:宋体;Times New Roman&quot;">数据操纵语言（<span lang="EN-US">Data 
                Manipulation Language，英文缩写为DML）就是对数据进行上述操作的语言。查询是用来对信息进行检索的语句。DML中涉及信息检索的那一部分称作查询语言。但在实际当中不严格区分查询语言和数据操纵语言，有时就简单地称为数据查询语言。 
                </span></span></p></td>
          </tr>
          <tr> 
            <td width="48" valign="middle"> <p class="MsoNormal" align="center" style="text-align:center"><b><span lang="EN-US" style="font-family:宋体;
  Times New Roman&quot;">3 </span></b></p></td>
            <td width="144" valign="top" class="section"> <p class="MsoNormal"><span style="font-family:宋体;Times New Roman&quot;">属性是用来描述实体集的，还是用来描述实体的？<span lang="EN-US"> 
                </span></span></p></td>
            <td width="372" valign="top"> <p class="MsoNormal"><span class="text" style="font-family:宋体;Times New Roman&quot;;
  Times New Roman&quot;">属性是用来描述实体集的，具体到实体集中的每个实体而言就是这些属性的具体取值</span><span class="text" style="font-family:宋体;Times New Roman&quot;">。<span style="color:black">形式化地说，实体集的属性是将实体集中的实体映射到域的函数。</span><span lang="EN-US"> 
                </span></span></p></td>
          </tr>
          <tr> 
            <td width="48" valign="middle"> <p class="MsoNormal" align="center" style="text-align:center"><b><span lang="EN-US" style="font-family:宋体;
  Times New Roman&quot;">4 </span></b></p></td>
            <td width="144" valign="top" class="section"> <p class="MsoNormal"><span style="font-family:宋体;Times New Roman&quot;">在确定用实体集还是联系集时，一个可采用的原则是什么？<span lang="EN-US"> 
                </span></span></p></td>
            <td width="372" valign="top"> <p class="MsoNormal"><span class="text" style="font-family:宋体;Times New Roman&quot;;
  Times New Roman&quot;">在确定用实体集还是联系集时一个可采用的原则就是：当描述发生在实体间的行为时最好采用联系集。</span><span class="text" style="font-family:宋体;Times New Roman&quot;" lang="EN-US"> 
                </span></p></td>
          </tr>
          <tr> 
            <td width="48" valign="middle"> <p class="MsoNormal" align="center" style="text-align:center"><b><span lang="EN-US" style="font-family:宋体;
  Times New Roman&quot;">5 </span></b></p></td>
            <td width="144" valign="top" class="section"> <p class="MsoNormal"><span style="font-family:宋体;Times New Roman&quot;">关系和表是一回事吗？<span lang="EN-US"> 
                </span></span></p></td>
            <td width="372" valign="top"> <p class="MsoNormal"><span class="text" style="font-family:宋体;Times New Roman&quot;">严格地说，关系和表不一样。关系是一系列域上的笛卡尔积的子集，是一个集合。既然关系是集合就不允许在集合中有重复的元组。按照课件的解释表</span><span class="text" style="font-family:宋体;Times New Roman&quot;;Times New Roman&quot;">可以看成是由一行一行的内容组成的一个格式，</span><span class="text" style="font-family:宋体;
  Times New Roman&quot;">每个表有多个列，每列有唯一的列名，而每个表也有一个唯一的名字。值得注意的是在关系数据库系统中，表中允许有重复的行存在，即允许有重复的记录。<span lang="EN-US"> 
                </span></span></p></td>
          </tr>
          <tr> 
            <td width="48" valign="middle"> <p class="MsoNormal" align="center" style="text-align:center"><b><span lang="EN-US" style="font-family:宋体;
  Times New Roman&quot;">6 </span></b></p></td>
            <td width="144" valign="top" class="section"> <p class="MsoNormal"><span lang="EN-US" style="font-family:宋体;Times New Roman&quot;">NULL是表示一个属性值非法吗？ 
                </span></p></td>
            <td width="372" valign="top"> <p class="text">不对，<span lang="EN-US">NULL是一个合法的属性值。它表示该属性的值为空值，空值的含义有两层意思，一是表示属性没有值；二是表示属性的值未知。当属性值未知时还有两种情况，一是值缺失，表示属性有值，但是我们目前还没有该值的信息；二是不知道该属性有没有值。 
                </span></p></td>
          </tr>
          <tr> 
            <td width="48" valign="middle"> <p class="MsoNormal" align="center" style="text-align:center"><b><span lang="EN-US" style="font-family:宋体;
  Times New Roman&quot;">7 </span></b></p></td>
            <td width="144" valign="top" class="section"> <p class="MsoNormal"><span style="font-family:宋体;Times New Roman&quot;">在关系代数和<span lang="EN-US">SQL中对查询结果的重复行的处理一样吗？ 
                </span></span></p></td>
            <td width="372" valign="top"> <p class="text">不一样。关系代数的运算结果仍然是一个关系，绝对不允许重复的元组在关系代数的结果中出现。而在<span lang="EN-US">SQL中，去掉查询结果中的重复行是一件非常耗时的操作，因此允许在SQL的查询结果中保留重复的行。可以通过DISTINCT选项说明SQL的查询结果是否要保留重复的行。 
                </span></p></td>
          </tr>
          <tr> 
            <td width="48" valign="middle"> <p class="MsoNormal" align="center" style="text-align:center"><b><span lang="EN-US" style="font-family:宋体;
  Times New Roman&quot;">8 </span></b></p></td>
            <td width="144" valign="top" class="section"> <p class="MsoNormal"><span style="font-family:宋体;Times New Roman&quot;">数据库中的视图和关系有什么区别？<span lang="EN-US"> 
                </span></span></p></td>
            <td width="372" valign="top"> <p class="text">视图是虚关系，在<span lang="EN-US">DBMS中只保存定义视图的SQL语句，而不保存视图的具体数据。当在查询中用到视图时，DBMS会根据其保存的视图的定义（即SQL语句）来得到有关的数据。如果在DBMS中保存视图的数据，这样的视图称之为实体化视图。而关系在DBMS中不仅存储有其定义，而且还存储有实实在在的数据。 
                </span></p></td>
          </tr>
          <tr> 
            <td width="48" valign="middle"> <p class="MsoNormal" align="center" style="text-align:center"><b><span lang="EN-US" style="font-family:宋体;
  Times New Roman&quot;">9 </span></b></p></td>
            <td width="144" valign="top" class="section"> <p class="MsoNormal"><span style="font-family:宋体;Times New Roman&quot;">对于同一个查询，用<span lang="EN-US">SQL表达式表示的查询结果和用关系代数表达式表示的查询结果一样吗？ 
                </span></span></p></td>
            <td width="372" valign="top"> <p class="text">严格地讲这两种表达式表示的结果应该一样，但要注意的是由于<span lang="EN-US">SQL在处理重复的行时非常耗时，所以如果在SQL语句中没有指明DISTINCT选项时，查询结果将保留重复的行。而关系代数表达式的运算结果是一个关系，因此结果肯定不会有重复的元组存在。 
                </span></p></td>
          </tr>
          <tr> 
            <td width="48" valign="middle"> <p class="MsoNormal" align="center" style="text-align:center"><b><span lang="EN-US" style="font-family:宋体;
  Times New Roman&quot;">10 </span></b></p></td>
            <td width="144" valign="top" class="section"> <p class="MsoNormal"><span style="font-family:宋体;Times New Roman&quot;">在同一个<span lang="EN-US">SQL语句中的having子句和where子句中的条件是什么样的关系？ 
                </span></span></p></td>
            <td width="372" valign="top"> <p class="text">如果在同一个查询中同时存在<span lang="EN-US">where子句和having子句，那么首先应该用where子句中的条件进行选择，满足where条件的记录通过group 
                by子句形成分组；然后在每个分组上应用having子句，不符合having条件的分组将被抛弃掉！having子句主要是针对分组进行条件限制。having子句中的条件只有在形成分组后才起作用，因此可以在having子句中使用聚集函数。 
                </span></p></td>
          </tr>
          <tr> 
            <td width="48" valign="middle"> <p class="MsoNormal" align="center" style="text-align:center"><b><span lang="EN-US" style="font-family:宋体;
  Times New Roman&quot;">11 </span></b></p></td>
            <td width="144" valign="top" class="section"> <p class="MsoNormal"><span lang="EN-US" style="font-family:宋体;Times New Roman&quot;">where子句中的子查询和from子句中的子查询有什么区别？ 
                </span></p></td>
            <td width="372" valign="top"> <p class="text">SQL提供了嵌套子查询的机制，子查询是嵌套在另一个查询中的select-from-where表达式。where子句中的子查询的目的是为了：⑴集合成员资格的确认；⑵集合的比较；⑶集合基数的测试。而from子句中的子查询被定义成一个关系，这个关系就是派生关系，派生关系是临时关系，可以像使用普通关系一样使用临时关系，但是查询完成之后临时关系就不复存在。 
              </p></td>
          </tr>
          <tr> 
            <td width="48" valign="middle"> <p class="MsoNormal" align="center" style="text-align:center"><b><span lang="EN-US" style="font-family:宋体;
  Times New Roman&quot;">12 </span></b></p></td>
            <td width="144" valign="top" class="section"> <p class="MsoNormal"><span style="font-family:宋体;Times New Roman&quot;">函数依赖</span><span style="  font-family: Symbol;  " lang="EN-US">a&reg;b</span><span style="font-family:宋体;Times New Roman&quot;">在关系<span lang="EN-US">r(R)上是满足的，但在关系模式R上不一定是成立的！为什么？ 
                </span></span></p></td>
            <td width="372" valign="top"> <p class="text">假设有如下的关系模式：<span lang="EN-US"> 
                </span></p>
              <p class="text"><i><span lang="EN-US" style="font-family:宋体;Times New Roman&quot;">Customer-schema</span></i><span lang="EN-US" style="font-family:宋体;Times New Roman&quot;"> 
                = (<i><u>customer-name</u>, customer-street, customer-city</i>) 
                </span></p>
              <p class="text">和关系：<span lang="EN-US"> </span></p>
              <p class="text"><i><span lang="EN-US" style="font-family:宋体;Times New Roman&quot;">customer</span></i><span lang="EN-US" style="font-family:宋体;Times New Roman&quot;">(<i>Customer-schema</i>) 
                </span></p>
              <p class="MsoNormal"><span class="text" style="font-family:宋体;Times New Roman&quot;">对于关系<i><span lang="EN-US">customer</span></i>来说，由于关系中的记录个数有限，因此函数依赖：<i><span lang="EN-US">customer-street</span></i></span><span class="text" style="  font-family: Symbol; " lang="EN-US">&reg;</span><span class="text"><i><span lang="EN-US" style="font-family:宋体;Times New Roman&quot;">customer-city</span></i><span style="font-family:宋体;Times New Roman&quot;;">可能</span></span><span class="text" style="font-family:宋体;Times New Roman&quot;">是满足的，即客户所在的街道函数确定客户所在的城市。但是对关系模式<i><span lang="EN-US">Customer-schema</span></i>来说，上述函数依赖却不一定成立！因为现实生活中，不同的城市具有相同名字的街道是很有可能的事情。<span lang="EN-US"> 
                </span></span></p></td>
          </tr>
          <tr> 
            <td width="48" valign="middle"> <p class="MsoNormal" align="center" style="text-align:center"><b><span lang="EN-US" style="font-family:宋体;
  Times New Roman&quot;">13 </span></b></p></td>
            <td width="144" valign="top" class="section"> <p class="MsoNormal"><span style="font-family:宋体;Times New Roman&quot;">函数依赖和码一样吗？<span lang="EN-US"> 
                </span></span></p></td>
            <td width="372" valign="top"> <p class="text">肯定不一样。函数依赖是一种特殊的约束，它是码概念的推广。简单地说，函数依赖是合法关系集上的约束。<span lang="EN-US"> 
                </span></p>
              <p class="text" style="text-autospace:none">1、码的定义： </p>
              <p class="text" style="  text-autospace:none">令<i><span lang="EN-US">R</span></i>是关系模式，<i><span lang="EN-US">R</span></i>的子集<i><span lang="EN-US">K</span></i>是<i><span lang="EN-US">R</span></i>的超码是指对任意的合法关系<i><span lang="EN-US">r(R)</span></i>及<i><span lang="EN-US">r</span></i>中的任意两个元组<span lang="EN-US">t<sub>1</sub>和t<sub>2</sub>，总能满足以下条件： 
                </span></p>
              <p class="text" align="center" style="text-align:center;text-autospace:none">若<span lang="EN-US">t<sub>1</sub>≠t<sub>2</sub>，则t<sub>1</sub>[<i>K</i>]≠t<sub>2</sub>[<i>K</i>] 
                </span></p>
              <p class="text" style="text-autospace:none">2、函数依赖 </p>
              <p class="MsoNormal" style="  text-autospace:none"><span class="text" style="font-family:宋体;Times New Roman&quot;">令</span><span class="text" style="  font-family: Symbol; " lang="EN-US">a&Iacute;</span><span class="text"><i><span lang="EN-US" style="font-family:宋体;Times New Roman&quot;">R</span></i><span style="font-family:宋体;Times New Roman&quot;">且</span></span><span class="text" style="  font-family: Symbol; " lang="EN-US">b&Iacute;</span><span class="text"><i><span lang="EN-US" style="font-family:宋体;Times New Roman&quot;">R</span></i><span style="font-family:宋体;Times New Roman&quot;">，<i><span lang="EN-US">R</span></i>存在函数依赖</span></span><span class="text" style="  font-family: Symbol; " lang="EN-US">a&reg;b</span><span class="text" style="font-family:宋体;">（读作</span><span class="text" style="  font-family: Symbol; " lang="EN-US">a</span><span class="text" style="font-family:宋体;
  ">函数确定</span><span class="text" style="  font-family: Symbol; " lang="EN-US">b</span><span class="text" style="font-family:宋体;">，或</span><span class="text" style="  font-family: Symbol; " lang="EN-US">b</span><span class="text" style="font-family:宋体;
  ">函数依赖于</span><span class="text" style="  font-family: Symbol; " lang="EN-US">a</span><span class="text" style="font-family:宋体;">）</span><span class="text" style="font-family:宋体;Times New Roman&quot;">是指对任意合法关系<i><span lang="EN-US">r(R)</span></i>及<i><span lang="EN-US">r</span></i>中任意两个元组<span lang="EN-US">t<sub>1</sub>和t<sub>2</sub>，总满足以下条件： 
                </span></span></p>
              <p class="MsoNormal" align="center" style="text-align:center;text-autospace:none"><span class="text" style="font-family:宋体;Times New Roman&quot;">若<span lang="EN-US">t<sub>1</sub>[</span></span><span class="text" style="  font-family: Symbol; " lang="EN-US">a</span><span class="text" style="font-family:宋体;Times New Roman&quot;" lang="EN-US">]=t<sub>2</sub>[</span><span class="text" style="  font-family: Symbol; " lang="EN-US">a</span><span class="text" style="font-family:宋体;Times New Roman&quot;" lang="EN-US">]，则t<sub>1</sub>[</span><span class="text" style="  font-family: Symbol; " lang="EN-US">b</span><span class="text" style="font-family:宋体;Times New Roman&quot;" lang="EN-US">]=t<sub>2</sub>[</span><span class="text" style="  font-family: Symbol; " lang="EN-US">b</span><span class="text" style="font-family:宋体;Times New Roman&quot;" lang="EN-US">] 
                </span></p>
              <p class="text">从上面的例子可以看出，码强调的是一组属性的集合可以唯一确定一个元组；而函数依赖强调的是如果两个元组在一组属性上的值相等，那么这两个元组在另外一组属性上的值也一定相等。<span lang="EN-US"> 
                </span></p></td>
          </tr>
          <tr> 
            <td width="48" valign="middle"> <p class="MsoNormal" align="center" style="text-align:center"><b><span lang="EN-US" style="font-family:宋体;
  Times New Roman&quot;">14 </span></b></p></td>
            <td width="144" valign="top" class="section"> <p class="MsoNormal"><span style="font-family:宋体;Times New Roman&quot;">在数据库设计中，如果已经确定使用某种关系型的商业数据库管理系统，那么数据库的物理设计的任务是什么呢？<span lang="EN-US"> 
                </span></span></p></td>
            <td width="372" valign="top"> <p class="text">在选定<span lang="EN-US">DBMS的情况下，那么从大的方面来讲数据库的物理设计的任务就是：确定数据的划分与分布、确定是否使用簇集技术、确定应该建立哪些索引、在有可能的情况下调整DBMS的某些系统参数以解决数据库应用的性能问题。 
                </span></p></td>
          </tr>
          <tr> 
            <td width="48" valign="middle"> <p class="MsoNormal" align="center" style="text-align:center"><b><span lang="EN-US" style="font-family:宋体;
  Times New Roman&quot;">15 </span></b></p></td>
            <td width="144" valign="top" class="section"> <p class="MsoNormal"><span style="font-family:宋体;Times New Roman&quot;">文件组织和文件中记录的组织一样吗？<span lang="EN-US"> 
                </span></span></p></td>
            <td width="372" valign="top"> <p class="MsoNormal" align="left" style="text-align:left;"><span class="text" style="font-family:宋体;Times New Roman&quot;;Times New Roman&quot;">不一样。文件在逻辑上是记录的序列，这些记录被映射到磁盘的物理块上。文件由操作系统作为一种基本的数据结构提供。将数据库映射到文件的方法有两种：</span><span class="text" style="font-family:宋体;color:black">⑴</span><span class="text" style="font-family:宋体">定长记录：使用多个文件，每个文件只存储同样长度的记录；</span><span class="text" style="font-family:宋体;color:black">⑵变长记录：使用一个文件，使之能够容纳不同长度的记录。<span lang="EN-US"> 
                </span></span></p>
              <p class="MsoNormal" align="left" style="text-align:left;"><span class="text" style="font-family:宋体;color:black">上面讲述的是数据库中的文件组织，即如何在文件中存储记录。而文件中记录的组织是指如何在文件中组织（或安排）这些记录。常用的几种方法是：</span><span class="text" style="font-family:宋体;color:black;
  " lang="EN-US"> </span></p>
              <p class="text">⑴堆文件组织<span lang="EN-US"> </span></p>
              <p class="text">⑵顺序文件组织<span lang="EN-US"> </span></p>
              <p class="text">⑶散列文件组织<span lang="EN-US"> </span></p>
              <p class="text">⑷聚集文件组织<span lang="EN-US">――簇集(clustering)文件组织 </span></p>
              <p class="MsoNormal"><span class="text" style="font-family:宋体;
  color:black">⑸<span lang="EN-US">B</span></span><span class="text" style="font-family:宋体;color:black;" lang="EN-US">+</span><span class="text" style="font-family:宋体;
  color:black">树文件组织<span lang="EN-US" style="display:none;"> </span></span></p></td>
          </tr>
          <tr> 
            <td width="48" valign="middle"> <p class="MsoNormal" align="center" style="text-align:center"><b><span lang="EN-US" style="font-family:宋体;
  Times New Roman&quot;">16 </span></b></p></td>
            <td width="144" valign="top" class="section"> <p class="MsoNormal"><span style="font-family:宋体;Times New Roman&quot;">搜索码和码是一回事吗？<span lang="EN-US"> 
                </span></span></p></td>
            <td width="372" valign="top"> <p class="MsoBodyText2"><span class="text" style="text-shadow:none">搜索码是指用于在文件中查找记录的属性或属性集，与码的概念完全不同。搜索码根本不具有码的任何性质，任何属性集都可以作为搜索码。简单地说码是关系中可以唯一确定一条记录的属性集，不是任何属性集都可以成为码的。一般在检索记录时都用码作为检索的条件，所以很容易将搜索码与码混淆。</span><span class="text" style="  display:none;text-shadow:none" lang="EN-US"> 
                </span></p></td>
          </tr>
          <tr> 
            <td width="48" valign="middle"> <p class="MsoNormal" align="center" style="text-align:center"><b><span lang="EN-US" style="font-family:宋体;
  Times New Roman&quot;">17 </span></b></p></td>
            <td width="144" valign="top" class="section"> <p class="MsoNormal"><span style="font-family:宋体;Times New Roman&quot;">存储桶和物理块有什么不同？<span lang="EN-US"> 
                </span></span></p></td>
            <td width="372" valign="top"> <p class="MsoNormal" align="left" style="text-align:left;"><span class="text" style="font-family:宋体">块是一个盘片的一条磁道内几个连续的扇区构成的序列。这里的块也称物理块<span lang="EN-US">,一般简称块</span></span><span class="text" style="font-family:宋体;display:none;" lang="EN-US"> 
                </span></p>
              <p class="MsoNormal" align="left" style="text-align:left;"><span class="text" style="font-family:宋体">，是磁盘<span lang="EN-US">I/O的基本单位。而</span>存储桶是由<span lang="EN-US">1至32个物理块构成的一种存储结构。结合索引文件组织，存储桶用于数据文件中数据单元的存储和传输。与物理块不同的是，存储桶只能包含整记录，即记录可以跨块存储但不能跨桶存储。</span></span><span class="text" style="font-family:宋体;display:none;
  " lang="EN-US"> </span></p></td>
          </tr>
          <tr> 
            <td width="48" valign="middle"> <p class="MsoNormal" align="center" style="text-align:center"><b><span lang="EN-US" style="font-family:宋体;
  Times New Roman&quot;">18 </span></b></p></td>
            <td width="144" valign="top" class="section"> <p class="MsoNormal"><span style="font-family:宋体;Times New Roman&quot;">在查询优化中，是不是只要为每个关系运算选择一个代价最小的算法，整个关系代数表达式的代价就最小呢？<span lang="EN-US"> 
                </span></span></p></td>
            <td width="372" valign="top"> <p class="text">一般来说，简单地为每个关系运算选择一个代价最小的算法，整个表达式的代价也可能最小。但这样做往往是事与愿违<span lang="EN-US">(例如，索引嵌套循环连接并不是实现连接运算代价最小的算法，但是它可以提供把结果流水地传给下一个运算的机会)！因此，必须采用一定的查询优化策略才能满足需要。DBMS中的查询优化方法包括基于代价的优化和启发式优化方法。 
                </span></p></td>
          </tr>
          <tr> 
            <td width="48" valign="middle"> <p class="MsoNormal" align="center" style="text-align:center"><b><span lang="EN-US" style="font-family:宋体;
  Times New Roman&quot;">19 </span></b></p></td>
            <td width="144" valign="top" class="section"> <p class="MsoNormal"><span style="font-family:宋体;Times New Roman&quot;">在<span lang="EN-US">DBMS中，并发执行和并行执行一样吗（事务的并发调度和并行调度的区别与此问题类似）？ 
                </span></span></p></td>
            <td width="372" valign="top"> <p class="text">要注意数据库系统中的“并发执行”并不是真正意义上的“并行执行”。首先，从用户的角度来看，这两种方式的结果是类似的，都是在一段时间内完成了多项任务。但是并发执行一般来说是单<span lang="EN-US">CPU进行处理，靠分时来造成同时执行的假相。针对数据库中事务的并发执行就是利用了计算机的磁盘I/O可以和CPU处理并行工作的特性，将不同事务的指令放在一起交叉执行。而并行执行一般是用多个CPU同时进行处理，是真正意义上的同时执行。深入的讨论在《操作系统》课程中可以找到。 
                </span></p>
              <p class="text">在单处理机系统中，事务的并行执行实际上是这些事务的并行操作轮流交叉运行。这种并行执行方式称为交叉并发方式。虽然单处理机系统中的并行事务并没有真正地并行运行，但是减少了处理机的空闲时间，提高了系统的效率。<span lang="EN-US"> 
                </span></p>
              <p class="text">在多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行。这种并行执行方式称为同时并发方式。<span lang="EN-US"> 
                </span></p></td>
          </tr>
          <tr> 
            <td width="48" valign="middle"> <p class="MsoNormal" align="center" style="text-align:center"><b><span lang="EN-US" style="font-family:宋体;
  Times New Roman&quot;">20 </span></b></p></td>
            <td width="144" valign="top" class="section"> <p class="MsoNormal"><span style="font-family:宋体;Times New Roman&quot;">串行调度与冲突可串行化调度一样吗？<span lang="EN-US"> 
                </span></span></p></td>
            <td width="372" valign="top"> <p class="MsoNormal"><span class="text" style="font-family:宋体;Times New Roman&quot;">串行调度与冲突可串行化调度描述的是不同的事情。串行调度由来自各个事务的指令序列组成，其中属于同一事务的指令在调度中紧挨在一起。对于有<span lang="EN-US">n个事务的事务组，共有n!个可能的串行调度方案。而冲突可串行化调度是指如果调度S（任意的一个调度，不一定是串行调度）可以经过一系列非冲突指令的交换变成一个串行调度S</span></span><span class="text" lang="EN-US">’</span><span class="text" style="font-family:
  宋体;Times New Roman&quot;">，则称<span lang="EN-US">S是冲突可串行化的调度。</span></span><span style="font-family:
  宋体;Times New Roman&quot;"><span lang="EN-US"> </span></span></p></td>
          </tr>
          <tr> 
            <td width="48" valign="middle"> <p class="MsoNormal" align="center" style="text-align:center"><b><span lang="EN-US" style="font-family:宋体;
  Times New Roman&quot;">21 </span></b></p></td>
            <td width="144" valign="top" class="section"> <p class="MsoNormal"><span style="font-family:宋体;Times New Roman&quot;">在两阶段封锁协议中，事务的封锁点是不是事务中最后一个加锁指令执行的时刻？是不是事务中第一个解锁指令的执行时刻呢？<span lang="EN-US"> 
                </span></span></p></td>
            <td width="372" valign="top"> <p class="text">都不是。事务的封锁点应该是该事务获得最后一个锁的时刻。<span lang="EN-US"> 
                </span></p></td>
          </tr>
          <tr> 
            <td width="48" valign="middle"> <p class="MsoNormal" align="center" style="text-align:center"><b><span lang="EN-US" style="font-family:宋体;
  Times New Roman&quot;">22 </span></b></p></td>
            <td width="144" valign="top" class="section"> <p class="MsoNormal"><span style="font-family:宋体;Times New Roman&quot;">为什么锁提升只能发生在事务的增长阶段，而锁降级只能发生在事务的缩减阶段？<span lang="EN-US"> 
                </span></span></p></td>
            <td width="372" valign="top"> <p class="text">因为锁提升就相当于给事务加某些特征的锁，例如将共享锁提升为排他锁，因此提升只能发生在事务的增长阶段；而锁降级就相当于给事务解部分锁，所以锁降级只能发生在事务的缩减阶段。<span lang="EN-US"> 
                </span></p></td>
          </tr>
          <tr> 
            <td width="48" valign="middle"> <p class="MsoNormal" align="center" style="text-align:center"><b><span lang="EN-US" style="font-family:宋体;
  Times New Roman&quot;">23 </span></b></p></td>
            <td width="144" valign="top" class="section"> <p class="MsoNormal"><span style="font-family:宋体;Times New Roman&quot;">在一个局域网中，有多台服务器都装有<span lang="EN-US">RDBMS，它们是否构成了一个分布式数据库系统？ 
                </span></span></p></td>
            <td width="372" valign="top"> <p class="text">不是。这样的系统只能看作是一个分散式的数据库系统，因为对于每一台服务器上的<span lang="EN-US">RDBMS来说，都不具有分布式DBMS（即DDBMS）的特征。 
                </span></p></td>
          </tr>
        </table>
      </div></td>
  </tr>
</table>
</body>
</html>
