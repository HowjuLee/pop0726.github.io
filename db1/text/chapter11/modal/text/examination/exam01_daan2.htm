<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset="utf-8"">
<link rel="stylesheet" href="../../css/text.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#000000" background="../../../../../image/pop/r2_c3.gif">
<center><table width="95%" border="0" cellspacing="0" cellpadding="0">
  <tr>
      <td class=text> 
        <p><b>问答题答案</b></p>
        <p><span class="explaination">问答第1题</span><br>
          　　首先，根据两阶段封锁协议下的并发控制管理器授权加锁的条件，事务在发出最后一个锁的申请之后还没有获得锁之前一直处于等待状态，等待别的事务释放锁。<br>
          　　 第二，根据两阶段封锁协议，事务获得最后一个锁之后就会全部执行完事务，因为事务再也没有申请锁，因而也就不会处于等待状态。因为封锁点是调度中事务获得最后一个锁的时刻，因此根据前面的两点，事务在封锁点之后会全部执行完事务中的操作，而在封锁点之前有可能会等待别的事务释放锁。因此调度中只可能是封锁点晚的事务有可能在等待封锁点早的事务释放锁，当封锁点早的事务释放有关的锁之后，封锁点晚的事务才有可能不继续等待而是执行。因此，从串行的角度将，封锁点晚的事务一定要在封锁点早的事务之后执行，才有可能保证与调度的并发执行等价，所以根据封锁点进行排序就是事务的一个可串行化次序。 
          <br>
          <img src="../../../../../image/shiti/42.gif" width="351" height="275"><br>
          如上图所示，事务T<font size="-5">i</font>、T<font size="-5">j</font>、T<font size="-5">k</font>的最后一个加锁指令都是lock(Q)，而且封锁点的顺序也是T<font size="-5">i</font>、T<font size="-5">j</font>、T<font size="-4">k</font>（图中用t<font size="-6">1</font>、t<font size="-5">2</font>、t<font size="-5">3</font>表示各自事务获得最后一个锁的时刻）。如果是T<font size="-6">i</font>先到达封锁点，那么有可能是T<font size="-6">j</font>在等待T<font size="-5">i</font>释放锁，这就是为什么虽然T<font size="-5">j</font>先发出最后一个锁的申请，但却在T<font size="-5">i</font>的封锁点之后才得到锁的原因，从串行的角度讲，T<font size="-5">i</font>一定要在T<font size="-6">j</font>之前执行。<br>
          <br>
          <span class="explaination">问答第2题</span><br>
          　　严格两阶段封锁协议除了要求封锁是两阶段之外，还要求事务持有的所有排他锁必须在事务提交之后方可释放。这个要求保证未提交事务所写的任何数据在该事务提交之前均以排他方式加锁，防止其他事务读取这些数据，这样带来的好处就是能够有效防止调度中的事务在发生故障时出现级联回滚的现象。 
          <br>
          　　 如果事务一开始就申请排他锁并获得该锁，那么根据严格两阶段封锁协议的要求，其他事务只能在该事务提交之后才有可能获得该锁而继续执行。也就是说，严格两阶段封锁协议虽然保证了调度不会发生级联回滚，但却降低了事务之间的并发度，有可能使事务的任何并发执行实际上都相当于串行执行。<br>
          <br>
          <span class="explaination">问答第3题</span><br>
          　　如果调度中的一个事务在时间戳排序协议下回滚，那么根据时间戳排序协议的要求，该事务一定存在与调度中其他事务相冲突的读写操作。如果回滚的事务保持原有的时间戳重启后进入系统，还会发出相同的读写请求，而根据时间戳排序协议的要求，该事务还有可能回滚，因此就有可能会发生一个事务重复回滚的现象，这种重复回滚的严重后果就是出现饿死现象。如果回滚的事务重启后使用新的时间戳，虽然该事务发出的仍然是相同的读写请求，但由于该事务的时间戳发生了变化，因此该事务就有可能不需要回滚了，饿死现象也就不可能发生了。<br>
          <br>
          <span class="explaination">问答第4题</span><br>
          　　解除死锁的常用方法是回滚一个或多个事务。在选择要回滚的事务时，总是要选择使回滚代价最小的事务作为牺牲者，但是有可能同一事务总是作为回滚代价最小的事务而被选中，因此该事务就不断地回滚，永远不能取得进展，也就是说发生了饿死现象。<br>
          <br>
          <span class="explaination">问答第5题</span><br>
          　　等待-死亡机制和受伤-等待机制的要求可以用如下的示意图来说明：<br>
          <img src="../../../../../image/shiti/43.gif" width="342" height="324"><br>
          　　因为任何时候均存在一个时间戳最小的事务，在这两个机制中，这个事务都不允许回滚。由于系统中事务的时间戳总是增长，而回滚的事务不赋予新的时间戳（时间戳保持不变，这是死锁预防机制的要求），因此被回滚的事务最终会变成时间戳最小的事务，从而不会再次回滚。也就是说在这两种机制下不会发生题目中所说的饿死现象。<br>
          <!--czp-wenda-daan-->
        </p>
      </td>
  </tr>
</table>
  </center>

</body>
</html>
