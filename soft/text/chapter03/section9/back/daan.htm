 
<link rel="stylesheet" href="../../../../css/text.css" type="text/css">
 
<body bgcolor="#FFFFFF" background="../../../../images/tanchu/di.gif" leftmargin="0" marginwidth="0">
<P class="section">三、选择填空 </P>
<P class="text">1、解答：A. ②,&nbsp; B. ⑤,&nbsp; C. ①,&nbsp; D. ①,&nbsp; E. ③。其中，D与E的答案可互换。</P>
<P class="text">2、解答：③、⑤、④、②、⑥、⑦、① </P>
<P class="text">3、解答： ③、⑥、④、⑦、②、⑤、① </P>
<P class="text">4、解答：A. ⑤,&nbsp; B. ⑦,&nbsp; C. ③,&nbsp; D. ④,&nbsp; E. ①</P>
<P class="text">5、解答：A. ③,&nbsp; B. ②,&nbsp; C. ①,&nbsp; D. ①,&nbsp; E. ②,&nbsp; 
  F. ①,&nbsp; G. ①,&nbsp; H. ②</P>
<P class="text">6、解答：A. ②,&nbsp; B. ⑤,&nbsp; C. ③,&nbsp; D. ③,&nbsp; E. ②<BR>
  &nbsp;<BR>
  7、解答：A. ②,&nbsp; B. ①,&nbsp; C. ④,&nbsp; D. ②,&nbsp; E. ①</P>
<P class="text">8、解答：A. ③&nbsp;B. ①&nbsp;C. ①&nbsp;D. ③&nbsp;E. ②</P>
<P class="text">9、解答：A. ③,&nbsp; B. ②,&nbsp; C. ③,&nbsp; D. ①,&nbsp; E.&nbsp; 
  ⑤</P>
<P class="section">四、问答题</P>
<P class="text"><span class="part">1、解答：</span>“自顶向下，逐步求精”是Niklaus Wirth提出的设计策略：即将软件的体系结构按自顶向下方式，对各个层次的过程细节和数据细节逐层细化，直到用程序设计语言的语句能够实现为止，从而最后确立整个的体系结构。<BR>
  �这样的结构实际就是一个模块的分层结构，即分层的过程。在实施时，采用抽象化的方法，自顶向下，给出不同的抽象层次。在最高的抽象层次上，可以使用问题所处环境的语言概括地描述问题的解法。而在较低的抽象层次上，则采用过程化的方法。在描述问题的解法时，我们可以配合使用面向问题的术语和面向现实的术语。但最后在最低的抽象层次上，我们应使用能够直接实现的方式来描述这个解法。</P>
<P class="text"><span class="part">2、解答：</span>软件设计既是过程又是模型。设计过程是一系列迭代的步骤，使设计人员能够描述被开发软件的方方面面。设计模型体现了自顶向下、逐步细化的思想，首先构造事物的整体，再逐步细化，引导人们构造各种细节。为了给软件设计人员提供一些指导，1995年Davis提出了一系列软件设计的原则如下，其中有些修改和补充：<BR>
  &nbsp;�・设计过程不应受“隧道视野”的限制。一位好的设计者应当考虑一些替代的手段。根据问题的要求，可以用基本的设计概念，如抽象、逐步求精、模块化、软件体系结构、控制层次、结构分解、数据结构、软件过程、信息隐蔽等，来决定完成工作的资源。<BR>
  &nbsp;�・设计应能追溯到分析模型。由于设计模型中每一单个成份常常可追溯到多个需求上，因此有必要对设计模型如何满足需求进行追踪。<BR>
  &nbsp;�・设计不应当从头做起。系统是使用一系列设计模式构造起来的，很多模式很可能以前就遇到过。这些模式通常被称为可复用的设计构件。可以使用它们代替那些从头开始做的方法。时间短暂而资源有限！设计时间应当投入到表示真正的新思想和集成那些已有的设计模式上去。<BR>
  &nbsp;�・设计应当缩短软件和现实世界中问题的“智力差距”，就是说，软件设计的结果应尽可能模拟问题领域的结构。<BR>
  &nbsp;�・设计应具有一致性和集成性。如果一个设计从整体上看像是一个人完成的，那它就是一致的。在设计工作开始之前，设计小组应当定义风格和格式的规则，如果仔细定义了设计构件之间的接口，则该设计就是集成的。<BR>
  &nbsp;�使用上述的基本的设计概念，将设计构造得便于将来的修改。<BR>
  &nbsp;�・应将设计构造得即使遇到异常的数据、事件或操作条件，也能平滑地、轻松地降级。设计良好的计算机程序应当永不“彻底停工”，它应能适应异常的条件，并且当它必须中止处理时也能以从容的方式结束。<BR>
  &nbsp;�・设计不是编码，编码也不是设计。即使在建立程序构件的详细的过程设计时，设计模型的抽象级别也比源代码要高。在编码级别上作出的唯一设计决策是描述如何将过程性设计转换为程序代码的小的实现细节。<BR>
  &nbsp;　・在开始着手设计时就应当能够评估质量，而不是在事情完成之后。利用上述的基本的设计概念和已有的设计方法，可以帮助设计者评估质量。<BR>
  &nbsp;　・应当坚持设计评审以减少概念上（语义上）的错误。有时人们在设计评审时倾向于注重细节，只见树木不见森林。在关注设计模型的语法之前，设计者应能确保设计的主要概念上的成份（的遗漏、含糊、不一致）都已检查过。</P>
<P><span class="part">3、解答：</span><span class="text">如果两个模块互相独立，那么对其中一个模块进行编码、测试或修改时可以完全不考虑另一个模块对它的影响。因此，用模块独立性作为衡量模块结构是否容易编码、容易测试、容易修改的标准是合适的。但是，在一个系统的模块结构中没有哪两个模块可以完全独立，所以，要力争模块之间尽量独立，以得到一个质量良好的模块结构。<BR>
  　一般采用两个准则度量模块独立性。即模块间的耦合和模块的内聚。模块间的耦合是模块之间的相对独立性（互相连接的紧密程度）的度量。模块之间的连接越紧密，联系越多，耦合性就越高，而其模块独立性就越弱。内聚是模块功能强度（一个模块内部各个成份彼此结合的紧密程度）的度量。一个模块内部各个成份之间的联系越紧密，则它的内聚性就越高，相对地，它与其它模块之间的耦合性就会减低，而模块独立性就越强。因此，模块独立性比较强的模块应是高内聚低耦合的模块。<BR>
  　一般模块之间可能的连接方式有七种，构成耦合性的七种类型。它们之间的关系为</span><BR>
  &nbsp;<IMG alt="" hspace=0 src="image/03.gif" align=baseline border=0 width="383" height="82"><BR>
  <span class="text">　低耦合的情形有非直接耦合、数据耦合和标记耦合，它们都是比较好的模块间的连接。特点是模块间的接口简单、规范。中度耦合的情形有控制耦合，它通过参数表传递控制参数。相对高的耦合情形有外部耦合和公共耦合，它们都是通过全局数据传递模块间的信息，不是说它们一定“坏”，但一定要注意使用这类耦合可能产生的后果，特别要防范这种后果。<BR>
  一般模块的内聚性分为七种类型，它们的关系如下图所示。</span><BR>
  <IMG alt="" hspace=0 src="image/04.gif" align=baseline border=0 width="383" height="82"><BR>
  &nbsp;&nbsp;&nbsp; <span class="text">　在上面的关系中可以看到，位于高端的几种内聚类型最好，位于中段的几种内聚类型是可以接受的，但位于低端的内聚类型很不好，一般不能使用。因此，人们总是希望一个模块的内聚类型向高的方向靠。模块的内聚在系统的模块化设计中是一个关键的因素。<BR>
  　内聚和耦合是相互关联的。在程序结构中各模块的内聚程度越高，模块间的耦合程度就越低。但这也不是绝对的。我们的目标是力求增加模块的内聚，尽量减少模块间的耦合，但增加内聚比减少耦合更重要，应当把更多的注意力集中到提高模块的内聚程度上来。</span></P>
<P class="text"><span class="part">4、解答：</span>所谓“模块独立性”是指软件系统中每个模块只涉及软件要求的具体的子功能，而和软件系统中其它的模块的接口是简单的。所谓的“信息隐蔽”是指每个模块的实现细节对于其它模块来说是隐蔽的。也就是说，模块中所包含的信息（包括数据和过程）不允许其它不需要这些信息的模块使用。<BR>
  　如果软件系统做到了信息隐蔽，即定义和实施了对模块的过程细节和局部数据结构的存取限制，那么这些模块相互间的接口就是简单的。这组模块的独立性就比较强。事实上，衡量模块独立性的一个准则就是模块内聚，达到信息隐蔽的模块是信息内聚模块，它是高内聚情形，模块独立性当然很强了。<BR>
  　一个对象的抽象数据类型，就是信息隐蔽的示例。例如，对于栈stack， 可以定义它的操作makenull（置空栈）、push（进栈）、pop（退栈）、gettop（取栈顶）和empty（判栈空）。这些操作所依赖的数据结构是什么样的? 
  它们是如何实现的? 都被封装在其实现模块中。软件的其它部分可以直接使用这些操作，不必关心它的实现细节。一旦实现栈stack的模块里内部过程或局部数据结构发生改变，只要它相关操作的调用形式不变， 
  则软件中其它所有使用这个栈stack的部分都可以不修改。 这样的模块结构具有很强的模块独立性。</P>
<P class="text"><span class="part">5、解答：</span>模块的内聚性与该模块在分层模块结构中的位置无关。事实上，一个好的模块化的程序系统，它所有的模块可以都是功能内聚的，即每一个模块就只干了一件事。用结构化设计方法建立起来的模块结构中的每一个模块都符合这个要求。把讨论范围再拓宽点，在纯面向对象范型的软件系统中，整个系统看作是一个类，它的子类可以看作是系统的子系统或高层模块，它们还可以有子类，……，这就形成一个类的层次结构。类的构造可以看成是一个抽象数据类型，实际上是信息内聚的。所以整个系统中从上到下，所有模块（对象类）都是信息内聚的模块。</P>
<P class="text"><span class="part">6、解答：</span>所谓“耦合性”是指模块之间联系的紧密程度的一种度量，而软件的“可移植性”是指将一个软件系统从一个计算机系统或环境移植到另一个计算机系统或环境中运行时所需工作量的大小。可移植性是用一组子特性，包括简明性、模块独立性、通用性、可扩充性、硬件独立性和软件系统独立性等，来衡量的。如果一个软件具有可移植性，它必然耦合性低，这样模块独立性要强。例如，有一个图形处理软件，它应具有二维几何图形处理、三维几何图形处理、图形显示、外设控制、数据库管理、用户界面控制、设计分析等模块。如果这些模块之间都是通过参数表来传递信息，那么它们之间的的耦合就是数据耦合或标记耦合等，都是低耦合。将来如果想要把它们移植到另一个外部环境中，这些模块容易修改（功能内聚），且接口清晰，修改可局部化。反言之，如果这些模块都是功能内聚或信息内聚的模块，模块之间的耦合都是低耦合，也对可移植性有促进。但不能讲具有低耦合性模块结构的软件一定具有可移植性，因为是否具有可移植性还有其它因素的影响。</P>
<P class="text"><span class="part">7、解答：</span>递归过程在求解复杂的大型问题时非常有效。常用的求解问题的方法，一种叫做“分而治之”的策略和“回溯”的策略，都可以用递归方法来解决。所谓“分而治之”的方法即是把大而复杂的问题化为规模稍小的子问题，用同样方法求解。如果分解后的子问题能够直接解决，就直接解出，然后再回推得到原来问题的解。所谓“回溯”方法就是如果一个大的问题在求解过程中从某一步出发有可选的多种解决方案，先选择一种解决方案，试探求解。如果求解失败，撤消原来的选择，再选一种解决方案，试探求解，……。如果用某一方案求解成功，则退回上一步并报告这一步求解成功；如果所有可选方案都试过，都求解失败，则退回上一步并报告求解失败。<BR>
  &nbsp;　软件设计过程中的“自顶向下，逐层分解”的做法与上述求解问题的策略是一致的。如果分解出来的子问题（子功能、子模块）相互独立性比较强，这种分解可以降低模块的复杂性，做到模块化。所以，只要分解出来的子问题与原来问题满足递归的情况，用递归方法建立模块结构也是可行的。</P>
<P class="text"><span class="part">8、解答：</span>软件设计是一个把软件需求变换成软件表示的过程。最初这种表示只是描绘出软件的总的框架，然后进一步细化，在此框架中填入细节，把它加工成在程序细节上非常接近于源程序的软件表示。正因为如此，所以从工程管理的角度来看，软件设计分两步完成。首先做概要设计，将软件需求转化为数据结构和软件的系统结构。然后是详细设计，即过程设计。通过对结构表示进行细化，得到软件的详细的数据结构和算法。<BR>
  &nbsp;　由于概要设计建立起整个系统的体系结构框架，并给出了系统中的全局数据结构和数据库接口，人机接口，与其它硬、软件的接口。此外还从系统全局的角度，考虑处理方式、运行方式、容错方式、以及系统维护等方面的问题，并给出了度量和评价软件质量的方法，所以它奠定了整个系统实现的基础。没有概要设计，直接考虑程序设计，就不能从全局把握软件系统的结构和质量，实现活动处于一种无序状态，程序结构划分不合理，导致系统处于一种不稳定的状态，稍一做改动就会失败。所以，不能没有概要设计。</P>
<P class="text"><span class="part">9、解答：</span>使用PDL语言，可以做到逐步求精：从比较概括和抽象的PDL程序起，逐步写出更详细的更精确的描述。下面举一个例子。<BR>
  　PROCEDURE&nbsp; spellcheck&nbsp; IS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  　　　　　　　　　　　查找错拼的单词&nbsp;&nbsp;&nbsp; <BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　　BEGIN<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　　　split document into 
  single&nbsp; words&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; 　　　　 把整个文档分离成单词<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　　　lood up words in dictionary&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  　　　　　　　在字典中查这些单词<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　　　display words which 
  are not in dictionary&nbsp;&nbsp; 显示字典中查不到的单词<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　　　create a new dictionary&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  &nbsp;&nbsp; 　　　　　　　　　造一新字典<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　　END spellcheck<BR>
  �这个例子只是搭起一个处理问题的框架。为进一步表明查找拼错的单词的4个步骤如何实现，可以对它每一步进行细化:<BR>
  &nbsp;&nbsp;&nbsp;�PROCEDURE spellcheck<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ��BEGIN<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ���--* 
  split document into single words<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ���LOOP 
  get next word<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  ����add word to word list in sortorder<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  ����EXIT&nbsp; WHEN all words processed<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ���END&nbsp; 
  LOOP<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ���--* 
  look up words in dictionary<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ���LOOP 
  get word from word list<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  ����IF word not in dictionary THEN<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  �����--* display words not in dictionary<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  �����display word，prompt on user terminal<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  �����IF user response says word OK THEN<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  ������add word to good word list<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  �����ELSE<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  ������add word to bad word list<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  �����ENDIF<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  ����ENDIF<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  ���EXIT WHEN all words processed<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ���END 
  LOOP<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ���--* 
  create a new words dictionary<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ���dictionary:＝merge 
  dictionary and good word list<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; �END spellcheck<br>
  �</P>


