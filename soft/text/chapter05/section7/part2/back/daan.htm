 
<link rel="stylesheet" href="../../../../../css/text.css" type="text/css">
<script language="JavaScript">
<!--
function MM_openBrWindow(theURL,winName,features) { //v2.0
  window.open(theURL,winName,features);
}
//-->
</script>
 
<body bgcolor="#FFFFFF" background="../../../../../images/tanchu/di.gif" leftmargin="0" marginwidth="0">
<P class="section">三、选择填空题</P>
<P class="text">&nbsp;<span class="part">1、解答：</span>A. ②&nbsp;&nbsp; B. ④&nbsp;&nbsp; 
  C. ①&nbsp;&nbsp; D. ④&nbsp;&nbsp; E. ④</P>
<P class="text">&nbsp;<span class="part">2、解答：</span>A. ②&nbsp;&nbsp; B. ③&nbsp;&nbsp; 
  C. ②&nbsp;&nbsp; D. ③&nbsp;&nbsp; E. ③&nbsp;&nbsp; F. ④<br>
  �到程序的测试为止，软件开发工作已经经历了许多环节，每个环节都可能发生问题。为了把握各个环节的正确性，人们需要进行各种确认和验证工作。<BR>
  �所谓确认，是一系列的活动和过程，其目的是想证实在一个给定的外部环境中软件的逻辑正确性。它包括需求规格说明的确认和程序的确认，而程序的确认又分为静态确认与动态确认。静态确认一般不在计算机上实际执行程序，而是通过人工分析或者程序正确性证明来确认程序的正确性；动态确认主要通过动态分析和程序测试来检查程序的执行状态，以确认程序是否有问题。<BR>
  �所谓验证，则试图证明在软件生存期各个阶段，以及阶段间的逻辑协调性、完备性和正确性。下图中所示的就是软件生存期各个重要阶段之间所要保持的正确性。它们就是验证工作的主要对象。</P>
<P>&nbsp;<IMG alt="" hspace=0 src="image/02.gif" align=baseline border=0 width="373" height="323"><br>
  �<span class="text">确认与验证工作都属于软件测试。在对需求理解与表达的正确性、设计与表达的正确性、实现的正确性以及运行的正确性的验证中，任何一个环节上发生了问题都可能在软件测试中表现出来。</span></P>
<P class="text">&nbsp;3、解答：A. ②&nbsp;&nbsp; B. ④&nbsp;&nbsp; C. ⑥&nbsp;&nbsp; 
  D. ③&nbsp;&nbsp; E. ①&nbsp;&nbsp; F. ②</P>
<P class="text">&nbsp;4、解答：A. ②&nbsp;&nbsp; B. ④&nbsp;&nbsp; C. ④&nbsp;&nbsp; 
  D. ②&nbsp;&nbsp; E. ①<BR>
  &nbsp;<BR>
  &nbsp;5、解答：(1) ②&nbsp;&nbsp; (2) ⑩&nbsp;&nbsp; (3) ⑨&nbsp;&nbsp; (4) ⑧&nbsp;&nbsp; 
  (5) ④<br>
  <br>
  6、解答：&nbsp;A. ③&nbsp;&nbsp;&nbsp; B. ④&nbsp;&nbsp;&nbsp; C. ②&nbsp;&nbsp; D. 
  ②&nbsp;&nbsp; E. ②<BR>
  �����F. ①&nbsp; &nbsp;&nbsp;&nbsp; G. ④&nbsp;&nbsp; H. ⑤&nbsp;&nbsp; I. ①&nbsp;&nbsp; 
  J. ①</P>
<P class="text">&nbsp;7、解答：&nbsp;A. ③&nbsp;B. ⑥&nbsp;C. ①&nbsp;&nbsp; D. ②&nbsp;&nbsp; 
  E. ⑥<BR>
  �����F. ②&nbsp;G. ①&nbsp;H. ③&nbsp;I. ⑤&nbsp;A、B的答案可互换<br>
  <br>
  8、解答：A. ①&nbsp;&nbsp; B. ⑤&nbsp;&nbsp; C. ①&nbsp;&nbsp; D. ②&nbsp;&nbsp; E. 
  ③<BR>
  �软件测试中常用的静态分析方法是引用分析和接口分析。接口分析用于检查模块或子程序间的调用是否正确。分析方法（白盒方法）中常用的方法是路径测试方法。非分析方法（黑盒方法）中常用的方法是等价类（划分）方法和因果图方法。因果图方法根据输出对输入的依赖关系设计测试用例。<br>
  <br>
  9、解答：A. ②&nbsp;&nbsp; B. ①&nbsp;&nbsp; C. ②&nbsp;&nbsp; D. ⑤&nbsp;&nbsp; E. 
  ③<br>
  <br>
  10、解答：A和D,B和C,</P>
<P class="section">四、问答计算题</P>
<P class="text">&nbsp;1<span class="part">、解答：</span>正确的叙述有(4)、(5)、(6)、(7)、（10）。<br>
  �黑盒测试主要是根据程序的有关功能规格说明和覆盖准则来设计测试用例，进行测试的，不是根据程序的内部逻辑来设计测试用例，这是白盒测试做的事情。在所有黑盒测试方法中，最有效的不是因果图法，而是边界值分析方法。测试的目的是尽可能多地发现软件中的错误，其附带的收获才是验证该软件已正确地实现了用户的要求。测试的一条重要原则是：发现错误多的程序模块，残留在模块中的错误也多。软件可靠性模型（Shooman）就是依据这个原则建立它的公式的。对于连锁型分支结构，若有n个判定语句，则有2n条路径。因此，随着n的增大，路径数增长非常快。单元测试时，因为桩模块要模拟子模块的功能，这不是一件容易的事情，而驱动模块只是控制被测模块的执行，所以桩模块的编写比驱动模块的编写要难得多。<BR>
  &nbsp;在程序设计风格方面，如果重复的代码段没有明显的功能，不可以抽取出来形成独立的公共过程或子程序，只有在这些代码段表现出独立的功能时，才可把它们抽取出来形成独立的公共过程或子程序。另外，程序效率的提高主要应通过选择高效的算法或使用高效的语言编译器来实现。GOTO语句概念简单，使用方便，在某些情况下，保留GOTO语句反能使写出的程序更加简洁，这句话是正确的。</P>
<P><span class="text">&nbsp;</span><span class="part">2、解答：</span><span class="text">对小程序进行穷举测试，不见得能保证程序百分之百正确。所谓穷举测试是拿所有可能的输入数据来作为测试用例（黑盒测试），或覆盖程序中所有可能的路径（白盒测试）。对于小程序来说，实际上并不能真正作到穷举测试。例如前面讲过，一个小程序P只有两个输入X和Y及输出Z，在字长为32位的计算机上运行。如果X、Y只取整数，考虑把所有的X、Y值都做为测试数据，按黑盒方法进行穷举测试，这样做可能采用的测试数据组（Xi，Yi），基数（radix）i的最大可能数目为：232×232＝264。如果程序P测试一组X、Y数据需要1毫秒，而且假定一天工作24小时，一年工作365天，要完成264组测试，需要5亿年。</span><BR>
  <IMG alt="" hspace=0 src="image/03.gif" align=baseline border=0></P>
<P>&nbsp;<span class="part">3、解答：</span><span class="text">单元测试又称模块测试，是针对软件设计的最小单位─程序模块，进行正确性检验的测试工作。其目的在于发现各模块内部可能存在的各种差错。单元测试需要从程序的内部结构出发设计测试用例。多个模块可以平行地独立进行单元测试。单元测试是在编码阶段完成的，每编写出一个程序模块，就开始做这个模块的单元测试，所以只要采用模块化方法开发软件，单元测试都是必需的。它可由编写程序的人来完成。因为它需要根据程序的内部结构设计测试用例，对于那些不了解程序内部细节的人，这种测试无法进行。</span></P>
<P><span class="text">&nbsp;</span><span class="part">4、解答：</span><span class="text">针对覆盖标准，相应的测试用例组如下</span><BR>
  <IMG alt="" hspace=0 src="image/05.gif" align=baseline border=0><BR>
  <IMG alt="" hspace=0 src="image/06.gif" align=baseline border=0 width="360" height="106"><BR>
  <span class="text">注意：测试是一个程序的执行过程。对于逻辑表达式 A or B，当A为真时不再对B做判断，对于逻辑表达式 A and 
  B，当A为假时不再对B做判断。未能做判断的条件，在解答中用“□”表示。</span><BR>
  <IMG alt="" hspace=0 src="image/07.gif" align=baseline border=0 width="371" height="191"><BR>
  <span class="text">此测试用例组在满足条件覆盖的情况下又满足了判定覆盖的要求。</span><BR>
  <IMG alt="" hspace=0 src="image/08.gif" align=baseline border=0 width="387" height="168"><BR>
  &nbsp;<span class="text">�在条件组合覆盖情形，(x?90)or(y?90)的组合有4种，与条件(x+y?140)的组合应有8种，但(x+y?140=F)and((x?90=T)or(y?90=T))不可能出现，因此，7个测试用例就够了。</span><BR>
  <IMG alt="" hspace=0 src="image/09.gif" align=baseline border=0 width="388" height="142"><BR>
  &nbsp;<span class="text">�因为流程图有3条路径，只需3个测试用例就够了。如果将判定中的复合条件表达式改为单个条件的嵌套选择结构，第一个判定有3条路径，其中两条路径通向第二个判定。第二个判定有4条路径，组合起来总共应有9条路径。但是，其中受测试条件的限制，有3条路径不可达，因此，程序中应有6条路径，需要6个测试用例来覆盖它们。</span></P>
<P><IMG alt="" hspace=0 src="image/10.gif" align=baseline border=0 width="377" height="334"><BR>
  <IMG alt="" hspace=0 src="image/11.gif" align=baseline border=0></P>
<P><span class="text">5、解答：A. ④&nbsp;&nbsp;&nbsp; B. ⑤&nbsp;&nbsp;&nbsp; C. ⑧&nbsp;&nbsp;&nbsp; 
  D. ④&nbsp;&nbsp;&nbsp; E. ⑤&nbsp;&nbsp;&nbsp; F. ⑧<BR>
  &nbsp;判定表</span><BR>
  <IMG alt="" hspace=0 src="image/13.gif" align=baseline border=0></P>
<P>&nbsp;<span class="text">�为判定覆盖选取测试用例情形：对第一个判定选取测试用例组Ⅰ和Ⅱ，当用Ⅰ覆盖判定的T分支时，不会走到第二个分支；当用Ⅱ覆盖判定的F分支时，第二个判定需另取一个测试用例组覆盖其T分支，此时取测试用例组Ⅲ或Ⅳ即可。因此，选择⑤或⑧均可。<BR>
  &nbsp;为条件覆盖选取测试用例情形：取测试用例组Ⅰ和Ⅳ就可以覆盖所有4个条件的取值。<BR>
  &nbsp;为路径覆盖选取测试用例情形：总共3条路径，需3个测试用例，可选使各路径为T的测试用例。Ⅰ、Ⅱ、Ⅲ或Ⅰ、Ⅱ、Ⅳ均可，可选⑤或⑧。</span></P>
<P><span class="text">&nbsp;6、解答：（1）流程图如下。</span><BR>
  <IMG alt="" hspace=0 src="image/14.gif" align=baseline border=0 width="363" height="230"></P>
<P><span class="text">(2) 测试用例设计</span><BR>
  &nbsp;<BR>
  &nbsp;<IMG alt="" hspace=0 src="image/15.gif" align=baseline border=0 width="378" height="376"><br>
  �<span class="text">画程序流程图是设计测试用例的关键。从以往同学解题的经验来看，在画流程图时就出错了。所以首先要把流程图中的逻辑关系搞清楚再画出正确的流程图。考虑测试用例设计需要首先有测试输入数据，还要有预期的输出结果。对于此例，控制循环次数靠循环控制变量i和循环终值high。循环0次时，取low 
  = high，此时一次循环也不做。循环一次时，取low +1 = high，循环二次时，取low+2 = high。</span></P>
<P><span class="text">&nbsp;�若出题时特别强调要使用BRO策略，条件V[i] &lt; pivot &amp;&amp; ++k≠i的约束集合为 
  { (&lt;, &lt; ), (&lt;, = ), (=, &lt;), (&gt;, &lt; ) }，因此，测试用例设计为：</span>&nbsp;<BR>
  <a href="#"><IMG hspace=0 src="image/16x.gif" align=baseline border=0 onClick="MM_openBrWindow('a.htm','','scrollbars=yes,width=600,height=500')" alt="单击放大" width="380" height="278"></a><BR>
  &nbsp;<span class="part">7、解答：</span><span class="text">(1) McCabe环路复杂性 = 5<BR>
  &nbsp;(2) 独立路径有5条：&nbsp;&nbsp;&nbsp; <BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ①③<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ①②⑤⑧……<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ①②⑤⑨……<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ①②④⑥……<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ①②④⑦……<BR>
  &nbsp;(3) 为各测试路径设计测试用例:<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; 路径①③：取n = 1<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; 路径①②⑤⑧……：取n = 2,<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 预期结果：路径⑤⑧③不可达&nbsp; <BR>
  &nbsp;&nbsp;&nbsp;&nbsp; 路径①②⑤⑨……：取n = 2,<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 预期结果：路径⑤⑨③不可达<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; 路径①②④⑥⑤⑧③：<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 取n = 2, V[0] = 2, V[1] = 1, 
  预期结果：k = 1, V[0] = 1, V[1] = 2<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; 路径①②④⑥⑤⑨③：<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 取n = 2, V[0] = 2, V[1] = 1, 
  预期结果：k = 1, 路径⑨③不可达<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; 路径①②④⑦⑤⑧③：<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 取n = 2, V[0] = 1, V[1] = 2, 
  预期结果：k = 0, 路径⑧③不可达<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; 路径①②④⑦⑤⑨③：<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 取n = 2, V[0] = 1, V[1] = 2, 
  预期结果：k = 0, V[0] = 1, V[1] = 2</span><BR>
  <IMG alt="" hspace=0 src="image/17.gif" align=baseline border=0></P>
<P class="text">&nbsp;<span class="part">8、解答：</span>设三角形的三条边分别为A, B, C。如果它们能够构成三角形的三条边，必需满足：A 
  &gt; 0，B &gt; 0，C &gt; 0，且A + B &gt; C，B + C &gt; A，A + C &gt; B。<BR>
  &nbsp;如果是等腰的，还要判断是否A = B，或B = C，或A = C。<BR>
  &nbsp;对于等边的，则需判断是否A = B，且B = C，且A = C。<BR>
  &nbsp;列出等价类表：</P>
<P>&nbsp;�<BR>
  &nbsp;<span class="text">测试用例设计（略）</span></P>
<P><span class="text">&nbsp;9、解答：<BR>
  (1) 因果图</span><BR>
  <IMG alt="" hspace=0 src="image/19.gif" align=baseline border=0 width="388" height="258"></P>
<P><span class="text">(2) 测试用例设计</span> <BR>
  <IMG alt="" hspace=0 src="image/20.gif" align=baseline border=0 width="369" height="290"></P>
<P class="text">测试用例&nbsp; 每一纵列为一个测试用例</P>
<P class="text">&nbsp;<span class="part">10、解答：</span>由shooman公式：</P>
<P class="text"><IMG alt="" hspace=0 src="image/21.gif" align=baseline border=0></P>
<P><span class="text">其中，IT = 105，MTTF1 = 0.4，T1 = 160，n1 = 100，MTTF2 = 2，T2 = 
  320，n2 = 300。得：</span><BR>
  <IMG alt="" hspace=0 src="image/22.gif" align=baseline border=0 width="374" height="106"></P>
<P class="text">&nbsp;�(1) &nbsp;解得程序中固有得错误总数ET = 350，此外K = 1000。<BR>
  &nbsp;�(2) &nbsp;设MTTF = 10，有</P>
<P><IMG alt="" hspace=0 src="image/23.gif" align=baseline border=0><BR>
  <BR>
  &nbsp;&nbsp;&nbsp; &nbsp;<span class="text">解得x = 340。由可靠性累积曲线EC (t) = ET (1-e-K1 
  t )，<BR>
  &nbsp;&nbsp;&nbsp; &nbsp;得&nbsp; 100 = 350 (1-e-160K1)<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 300 = 350 
  (1-e-320K1)<BR>
  &nbsp;&nbsp;因此，3-3*e-160K1 = 1-e-320K1<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; 2 = 3*e-160K1- e-320K1&nbsp;&nbsp;&nbsp; 设 x = e-160K1&nbsp;&nbsp;&nbsp;&nbsp; 
  <BR>
  &nbsp;&nbsp;&nbsp; &nbsp;有 x2 �C 3x + 2 = 0<BR>
  &nbsp;&nbsp;解得 x1 = 2，x2 = 1,&nbsp; K1 = ln(x1)/(-160) = - 0.693/160 ? 0.00433。<BR>
  &nbsp;&nbsp;因为ln(x2)/(-160) = 0，舍去<BR>
  &nbsp;&nbsp;代入：340 = 350 (1-e-K1 t ) = 350(1-e-0.00433 t )<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  350e-0.00433 t = 10<BR>
  &nbsp;&nbsp;&nbsp;&nbsp; t = (ln(35))/0.00433 ? 821 (小时)<BR>
  &nbsp;&nbsp;&nbsp; &nbsp;因此求得为使MTTF = 10，测试和调试该程序需要花费821小时。<BR>
  �(3)&nbsp;MTTF与测试时间t之间的函数关系：&nbsp;&nbsp;<BR>
  &nbsp;因为EC (t) = ET (1-e-K1 t )，则ET - EC (t) = ET e-K1 t。代入shooman公式：<BR>
  <IMG alt="" hspace=0 src="image/24.gif" align=baseline border=0></span></P>
<P class="text">&nbsp;<span class="part">11、解答：</span>在对照需求做有效性测试和软件配置审查时，是由软件开发者在开发环境下进行的测试。而接下来做验收测试时则以用户为主。软件开发人员和QA（质量保证）人员也应参加。由用户参加设计测试用例，使用用户界面输入测试数据，并分析测试的输出结果。一般使用生产中的实际数据进行测试。<BR>
  �如果软件是为多个客户开发的，则需要进行α测试和β测试。α测试是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的测试。软件在一个自然设置状态下使用。开发者坐在用户旁边，随时记下错误情况和使用中的问题。这是在受控制的环境下进行的测试。<BR>
  �β测试是由软件的多个用户在一个或多个用户的实际使用环境下进行的测试。这些用户是与公司签定了支持产品预发行合同的外部客户，他们要求使用该产品，并愿意返回有关错位错误信息给开发者。与α测试不同的是，开发者通常不在测试现场。因而，β测试是在开发者无法控制的环境下进行的软件现场应用。</P>


