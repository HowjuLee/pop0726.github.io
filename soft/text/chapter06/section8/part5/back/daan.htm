 
<link rel="stylesheet" href="../../../../../css/text.css" type="text/css">
 
<body bgcolor="#FFFFFF" leftmargin="0" marginwidth="0" background="../../../../../images/tanchu/di.gif" topmargin="0" marginheight="0">
<P class="section">三、选择填空题</P>
<P class="text"><span class="part">1、解答：</span>(1) ④&nbsp;&nbsp; (2) ③&nbsp;&nbsp; 
  (3) ⑥&nbsp;&nbsp; (4) ②</P>
<P class="text">�逻辑性的范型把有关问题的知识分解成一组具体的规则，这些规则常常是用一种语言的“if_then”结构等来表示。<BR>
  �过程性的范型产生过程的抽象，这些抽象把软件视为处理流，定义构成一系列步骤的算法，每一步骤都是带有预定义输入和特定输出的一个过程，把这些步骤串联在一起可产生合理的稳定的贯通于整个程序的控制流。<BR>
  �面向对象范型把标识和模型化问题论域中的主要实体做为系统开发的起点，主要考虑对象的行为而不是必须执行的一系列动作。面向对象系统中的对象是数据抽象与过程抽象的一个混合体。表示这些实体的数据抽象是面向对象设计过程的主要产品，系统的状态保存在各个数据抽象的核心所定义的数据存储中。控制流被分成块，并被包括在各个在数据抽象上的各个操作里面。<BR>
  �面向进程的范型把一个问题分解成独立执行的模块。在某种意义上来说，就是让不只一个程序同时运行。这些程序，或更正确地说，这些进程互相配合，从而解决问题。可以认为一个进程在面向进程开发模式中就是一个模块(构件)。面向进程开发模式产生的主要的块是进程。在一个进程中的活动总的来说是独立于其它进程的那些活动的，除非要求从其它进程得到信息，或为其它进程提供信息。甚至可以异步处理，仅需要进程暂停发送或接收信息。<BR>
  �在面向对象范型中，各个对象是相对独立的，但也存在单线索控制。面向进程范型支持与面向对象范型相同的封装，但可继续提供多线索(线程)执行。&nbsp; </P>
<P class="text"><span class="part">2、解答：</span>A. ①,&nbsp; B. ⑤,&nbsp;C. ③,&nbsp;D. 
  ②&nbsp;E. ③</P>
<P class="text">�对象是面向对象范型的基本单位。每个对象可用它自己的一组属性和它可以执行的一组操作来表征。应用执行对象的操作可以改变该对象的属性，属性一般只能通过操作来改变。它的应用必须通过消息的传递。发送给一个对象的消息定义了一个方法名和一个参数表（可能是空的），并指定某一个对象。而由一个对象接收的消息则引用消息中指定的方法的代码，并将实际参数与参数表中相应的形式参数结合起来。接收对象对消息的处理可能会改变对象中的状态，即改变接收对象的属性，并发送一个消息给自己或另一个对象。</P>
<P class="text"><span class="part">3、 解答：</span>A. ①,&nbsp; B. ③,&nbsp; C. ④,&nbsp; 
  D. ②,&nbsp;&nbsp;&nbsp; E. ③,&nbsp;&nbsp;&nbsp; F. ④<BR>
  �在设计与实现类的时候，有三种利用既存类的途径：<BR>
  �・原封不动地复用既存类。<BR>
  �・对既存类进行演化以得到满足要求的类。<BR>
  �・重新开始进行开发。</P>
<P class="text"><span class="part">4、解答：</span>A. ②,&nbsp; B. ③,&nbsp; C. ①,&nbsp; 
  D. ④,&nbsp;&nbsp; E. ③</P>
<P class="text">　类，就它是一个数据值的聚合的意义上来看，与Pascal中的记录或C中的结构类似，但又有差别。类扩展了通常的记录语义，可提供各种级别的可访问性。也就是说，记录的某些成份可能是不可访问的，而这些成份对于本记录型来说具有可访问性。类不同于记录，因为它们包括了操作的定义，这些操作与类中声明的数据值有相同的地位。</P>
<P class="text"><span class="part">5、解答：</span>A. ④,&nbsp; B. ⑥,&nbsp; C. ②,&nbsp; 
  D. ①,&nbsp;&nbsp; E. ③<BR>
  &nbsp;<BR>
  　CRC是Class(类)、Responsibility(职责)和Collaborators(协作者)的缩写。这个技术是由Beck等开发的，在标识实体和定义界面的行为时在小组对话中使用。由于它的简单有效，以后逐渐成为职责驱动方法的一部分，并结合到其它的面向对象方法中去。CRC卡片的特点是用人格化的方法，将软件系统中的每个部件，即类，看成一个独立的个体，在探索如何与其它个体携手合作完成某一系统功能中逐步完成自身的定位。为了便于分组，查找，以及修改。每张卡片分为三个部分，分别记录一个类的名称，它的主要职责和协作者。以CRC卡片为辅助工具的设计有以下几个步骤：<BR>
  　(1) 识别类和职责：CRC卡片的作者建议使用自然语言的分析方法(LIA)，从用户需求规格说明书中的名词，物理和概念的实体中发现有用的类。引进适当的基类或子类，以形成继承关系的层次结构。然后，从用户的需求说明书中寻找对有关的信息和行为的描述，以发现职责。职责就是需做的事，必须完成的任务，后要解决的问题，但不涉及如何实现。<BR>
  　(2) 分配职责：将职责分配到类，并记录在相应的卡片上。CRC的作者指出应尽可能确保行为与有关信息不要分开，与同一实体的信息要集中在一起。如有必要，有些职责可以由几个类共同承担。<BR>
  　(3) 找寻协作者：任何一个类在完成自己的职责时往往都需要其它类的协作。这一步就是要找到与每一个类协作的伙伴，并记录在相应的卡片上。具体做法是依次检查每一类所承担的每一项责任，看是否需要其它类的帮助来完成。如果需要，进一步确定需要其做什么。<BR>
  　通常在模拟一个场景的过程中，每当一个类开始“执行”时，它的卡片就被拿出来加以讨论，当“控制”传送到另一个类时，我们的注意力就从前一张卡片转移到另一张上去了。不同的场景，包括例外和出错状况，都应逐一加以模拟。在这个过程中，可以验证已有的定义，不断发现新的类、职责以及伙伴。<BR>
  　用CRC卡片来进行设计，既不是传统的“自上而下”，也不是“自下而上”，而是从已知到未知的逐步展开的过程。场景模拟有助于以试验性的方式来从事设计。由于检索卡片灵活、易于修改，不同的设计方案可以很快地形成，并进行检验。</P>
<P class="text"><span class="part">6、解答：</span>A. ③,&nbsp; B. ②,&nbsp; C. ②,&nbsp; 
  D. ④,&nbsp;&nbsp; E. ③</P>
<P><span class="text">　语义数据模型来源于Codd的关系数据模型和实体―联系模型，并对这类模型进行了扩充和一般化。语义数据模型可以表达问题论域的内涵，还可以表示复杂对象和对象之间的联系。语义数据模型与关系数据模型本来都是在数据库设计时使用的，但它们的范围已经扩展到系统的开发。作为数据库结构标准的ANSI／SPARC建议提出了三层模型：外部模型、概念模型和内部模型。这三层可以被映象到面向对象设计的三个层次上去，如表所示。外部模型与概念模型层相当于高层设计阶段。</span><BR>
  <BR>
  <IMG alt="" hspace=0 src="image/13.gif" align=baseline border=0><BR>
  <BR>
  <span class="text">(1) 外部模型层。外部模型是来自应用的外部现实世界的视图，它反映了用户对问题的理解而不是实现者对问题的理解。在这一层开发的类应具有对应于用户活动的操作规格说明。<BR>
  (2) 概念模型层。概念模型层考虑在外部模型层所标识的实体之间的联系。这些联系就是可直接观察到的交互关系。在这一层，通常可以由系统的用户来识别和理解这些联系。<BR>
  联系的重要属性是实例连接。一个联系的实例连接是指在该联系中一个实体的实例对应于该联系中其它实体的实例的数目。<BR>
  (3) 内部模型层。这一层考虑实体的物理模型，这是我们生存期中的类设计阶段。物理模型包括两类属性：数据和方法。方法属性对实体的行为模型化，而数据属性对实体的状态模型化。在模型中方法分为两种：一种可作为共有界面来使用，而另一种是私有的。</span></P>
<P><span class="part">7、解答：</span><span class="text">A. ①,&nbsp; B. ④,&nbsp; C. 
  ⑤,&nbsp; D. ②,&nbsp;&nbsp; E. ④</span><BR>
  <BR>
  <IMG alt="" hspace=0 src="image/02.gif" align=baseline border=0></P>
<P class="text">　从分析到设计的过程流如图所示。一旦已经开发完成一个合理完整的分析模型后，就要着手子系统的设计。这需要描述子系统的特征，以准确表达待实现的用户需求，以及实现需求所必须的支持环境。<BR>
  　在定义子系统时，需要在用户需求的整个上下文环境中互相协调：各个用户需求分配给哪个子系统？在OOA中定义的对象驻留在哪个子系统内？哪些子系统并发运行？负责协调和控制它们的系统构件是谁？全局资源在子系统中如何管理？等。<BR>
  在设计子系统的过程中，需要定义4种重要的设计构件：<BR>
  　・问题论域：负责实现用户需求的子系统。<BR>
  　・人机交互：实现用户界面的子系统（包括可复用的GUI子系统）。<BR>
  　・任务管理：负责控制和协调各种事件驱动、时钟驱动、并发执行任务的子系统。<BR>
  　・数据管理：负责对象存储和检索的子系统。<BR>
  　每一个构件都可以用一些类、必须的关系和行为来定义。构件之间的关系可以通过建立每个构件的消息模型来建立。<BR>
  　一旦定义了各个子系统，包括上述的各个设计构件，就开始对象(类)设计，这时，可利用CRC卡片，将类转换为设计实现，转换工作如图所示。</P>
<P><IMG alt="" hspace=0 src="image/03.gif" align=baseline border=0><BR>
  <BR>
  <span class="part">8、解答：</span><span class="text">A. ⑦&nbsp;&nbsp; B. ⑥&nbsp;&nbsp; 
  C. ③&nbsp;&nbsp; D. ⑥&nbsp;&nbsp; E. ②</span></P>
<P class="text">　在OMT中，把分析时收集的信息建立在三个模型中。第一个模型是对象模型，它的作用是描述系统的静态结构，包括构成系统的对象和类，它们的属性和操作，以及它们之间的联系。第二个模型是动态模型，它描述系统的控制逻辑，主要涉及系统中各个对象和类的时序及变化状况。动态模型包括两种图， 
  即状态迁移图和事件追踪图。状态迁移图描述每一类对象的行为，事件追踪图描述发生于系统执行过程中的某一特定场景。第三个模型是功能模型，它着重于描述系统内部数据的传送与处理，它由多个数据流图组成。</P>
<P class="text"><span class="part">9、解答：</span>A. ③&nbsp;&nbsp; B. ②&nbsp;&nbsp; 
  C. ③&nbsp;&nbsp; D. ①&nbsp;&nbsp; E. ⑤</P>
<P class="text">　在面向对象软件设计过程中，应按如下要求进行类的设计：只有类的共有界面的成员才能成为使用类的操作，这就是软件设计的信息隐蔽原则。当且仅当一个操作对类的实例的用户有用时，它才是类公共界面的一个成员，这是软件设计的最小界面原则。由同属一个类的操作负担存取或加工类的数据，这是软件设计的高内聚原则。两个类之间的交互应当仅涉及参数表，这是软件设计的显式信息传递原则。每个派生类应该当做基类的特殊化来开发，而基类所具有的公共界面成为派生类的共有界面的一个子集，这是软件设计的继承性原则。</P>
<P class="text"><span class="part">10、解答：</span>A. ④&nbsp;&nbsp; B. ①&nbsp;&nbsp; 
  C. ③&nbsp;&nbsp; D. ④&nbsp;&nbsp; E. ①&nbsp;&nbsp; </P>
<P class="text">　其中，B、C、D的答案可互换。面向对象的程序设计语言应具备面向对象方法所要求的4个成分：类、对象、继承和消息通信。类与对象由数据抽象和信息隐蔽得到，此外语言应具有信息继承的机制。<BR>
  　对象由一组属性和它可以执行的一组操作来定义。面向对象的软件系统通过对象间的消息通信和对象执行消息所要求的服务完成系统预定的功能。所以，对象在计算中可向其他对象发送消息，接受消息的对象必须通过响应消息�M执行服务，给消息发送者以回答。<BR>
  　C++，Smalltalk，object C是面向对象的程序设计语言，Ada、Modula2是基于对象的程序设计语言，因为它缺少继承的机制，而Pascal，C，APL等都不是面向对象或基于对象的程序设计语言。</P>
<P class="section">四、问答题</P>
<P class="text"><span class="part">1、解答：</span>关于“面向对象”，有许多不同的看法。Coad和Yourdon给出了一个定义：“面向对象 
  = 对象 + 类 + 继承 + 消息通信”。如果一个软件系统是使用这样4个概念设计和实现的，则认为这个软件系统是面向对象的。面向对象方法的特点是：<BR>
  　・方法的唯一性，即方法是对软件开发过程所有阶段进行综合考虑而得到的。<BR>
  　・从生存期的一个阶段到下一个阶段的高度连续性，即生存期后一阶段的成果只是在前一阶段成果的补充和修改。<BR>
  　・把面向对象分析(OOA)、面向对象设计(OOD)和面向对象程序设计(OOP)集成到生存期的相应阶段。<BR>
  使用面向对象方法开发软件的好处是：<BR>
  　・开发方法的唯一性，开发阶段的高度连续性，表示方式的一致性；<BR>
  　・问题空间实体的自然表示，减轻了设计者的负担，在设计系统之初不必考虑一个很完整的解决方案。<BR>
  　・建立稳定的系统结构，可促进复用性，易于维护，易于修改，可合理利用共同性，减少复杂性。</P>
<P class="text"><span class="part">2、解答：</span>对象的定义：<BR>
  　・对象是面向对象开发模式的基本成分，是现实世界中个体或事物的抽象表示。<BR>
  　・每个对象可由一组属性和它可以执行的一组操作来定义。<BR>
  可能的潜在对象有7类：<BR>
  　① 外部实体：它们产生或接受为目标系统所使用的信息。如各种物理设备、使用人员、其它相关的子系统。 <BR>
  　② 事物：问题的信息域所涉及的概念实体。如各种报告、显示、文字、信号、规格说明等。<BR>
  　③ 事件：系统运行时发生的并需要系统记忆的事件。如状态转换、物理运动等。 <BR>
  　④ 角色：与系统有交互的各种人员所扮演的角色。如经理、工程师、销售人员等。 <BR>
  　⑤ 场所或位置：建立系统整体环境或问题上下文的场所、位置。如基于计算机的系统的安装场所等。 <BR>
  　⑥ 组织机构：与应用有关的组织机构。如&#61620;&#61620;组织，&#61620;&#61620;部门等。<BR>
  　⑦ 结构：定义由一组成分对象组成的聚合对象，或在极端情况下，定义对象的相关类。如传感器、四轮驱动车、计算机等。</P>
<P class="text"><span class="part">3、解答：</span>把具有相同特征和行为的对象归在一起就形成了类。类成为某些对象的模板，抽象地描述了属于该类的全部对象的属性和操作。属于某个　类的对象叫做该类的实例。对象的状态则包含在它的实例变量，即实例的属性中。类定义了各个实例所共有的结构，类的每一个实例都可以使用类中定义的操作。实例的当前状态是由实例所执行的操作定义的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  <BR>
  　类，就它是一个数据值的聚合的意义上来看，与Pascal中的记录或C中的结构类似，但又有差别。类扩展了通常的记录语义，可提供各种级别的可访问性。也就是说，记录的某些成份可能是不可访问的，而这些成份对于本记录型来说具有可访问性。类不同于记录，因为它们包括了操作的定义，这些操作与类中声明的数据值有相同的地位。</P>
<P><span class="part">4、解答：</span><span class="text">基于复用的面向对象开发过程分为6个阶段，如图中虚线框所围。</span><BR>
  <BR>
  <IMG alt="" hspace=0 src="image/04.gif" align=baseline border=0><BR>
  <span class="text"><BR>
  ① 论域分析 ：论域分析开发问题论域的模型。论域分析应当在应用分析之前进行，我们在了解问题之前应当对问题敞开思想考虑，考察问题论域内的一个较宽的范围，分析覆盖的范围应比直接要解决的问题更多。<BR>
  ② 应用分析 ：应用(或系统)分析细化在论域分析阶段所开发出来的信息，并且把注意力集中于当前要解决的问题。因为通过论域分析，分析人员具有了较宽的论域知识，因而能开发出更好的抽象。<BR>
  ③ 高层设计 ：在一个纯面向对象环境中，软件体系结构设计与类设计常常是同样的过程，但还是应当把体系结构设计与类的设计分开。在高层设计阶段，设计应用系统的顶层视图。这相当于开发一个代表系统的类，通过建立该类的一个实例并发送一个消息给它来完成系统的“执行”。<BR>
  ④ 类的开发 ：根据高层设计所标识的对各个类的要求和类的规格说明，进行类的开发。因为一个应用系统往往是一个类的继承层次。对这些类的开发是最基本的设计活动。<BR>
  ⑤ 实例的建立：建立各个对象的实例，实现问题的解决方案。<BR>
  ⑥ 组装测试：按照类与类之间的关系组装一个完整的应用系统的过程中进行的测试。各个类的封装和类测试的完备性可减少组装测试所需要的时间。</span></P>
<P><span class="part">5、解答：</span><span class="text">按照下图所示的类生存期，类的开发有三种方式。</span><BR>
  <BR>
  <IMG alt="" hspace=0 src="image/05.gif" align=baseline border=0><BR>
  <BR>
  <span class="text">(1) 既存类的复用<BR>
  　只要有可能就应复用既存类。为了达到此目的，开发人员必须能够找到这样一些类，它们都能选用来提供所需要的行为。有时应用要解决的问题与以前遇到的一些问题密切相关，因此那些问题中定义和实现的类可以复用。然而，多数照原样复用被限制在低层上最基本的类，像基本数据结构。对于较一般的结构，可以在实例化时，使用参数来规定它们的行为。<BR>
  (2) 从既存类进行演化<BR>
  　多数复用情况是一个类已经存在，它提供的行为类似于要为新类定义的行为。开发人员可以使用既存类做为定义新类的起点。新类将根据既存类渐进式地演变而成。这样，在开发一个新类时，只需要花费较少的工作量就能复用许多既存类，得到所需要的新类。演化可以是横向的，也可以是纵向的。横向的演化导致既存类的一个新的版本，而纵向的演化将从既存类导出新类。我们在这里将主要讨论类的纵向渐进式开发。<BR>
  　① 渐进式设计。设计既存类的一个特殊化类。通过确定新类中打算要的所有成员，设计者可以确定哪些追加的行为可以加到类中去，哪些既存的行为应当重新实现。<BR>
  　② 渐进式实现。许多实现可以从既存类直接继承；有时可以仅使用很少的新代码就能利用既存类的实现，而这些新代码必须当做老方法的上文或下文进行编写。此外，在渐进式设计阶段增加的那些行为也必须实现。<BR>
  　③ 渐进式测试。在测试中最花费时间的就是测试用例的生成。许多新类的测试用例可以从既存类的测试用例组中得到。新类的某些部分因为在测试既存类时已经测试过，因此可以不再需要测试。<BR>
  (3) 从废弃型进行开发<BR>
  　这个分支仅在不得已的情况下使用。任何一个类，只要它的开发不涉及既存类，就可看做是一个新的继承结构的开始。因此，将建立两种类：一种是抽象类，它概括了将要表达的概念；另一种是具体类，它要实现这个概念。<BR>
  　① 设计。设计阶段需把分析阶段所产生的界面当做输入，并确定类的其它属性。设计给出类的所有细节。这个阶段的输出是有关类的属性的足够的细节，可支持它们的实现。单个类的设计包括构造数据存储，它是类定义的核心。其内部表示还包括一些私有函数，它们实现了共有操作的某些部分。单个类的低层设计还涉及一些重要联系，如继承和组装关系。<BR>
  　② 实现。通过变量的声明、操作界面的实现及支持界面操作的函数的实现，可实现一个类的预期行为和状态。在变量中存储的数据通常是其它类的实例，它们提供了为该类的开发所需的服务。<BR>
  　③ 测试。单个的类为测试提供了自然的单元。如果类的定义提供的界面比较狭窄，那么穷举测试就有可能实现。类的测试在最抽象的层次开始，沿继承联系继续向下进行，新的类可以很容易地完全地被测试，而已经测试过的部分就不需要从新测试了。<BR>
  (4) 求精和维护<BR>
  　传统的维护活动是针对应用的，而求精过程则是针对类，并把类链接在一起的结构的。因为我们利用抽象进行开发，因此，维护部分在任一时间都能修改这些抽象。随着经验的增长，我们可以够标识抽象的抽象，使得继承结构通过泛化增加新的层次，即在既存的根类之上增加新的层次。</span></P>
<P class="text"><span class="part">6、解答：</span>结构化开发方法是使用最广泛、历史最长的过程化开发方法。结构化开发方法产生过程的抽象，这些抽象把软件视为处理流，定义构成一　系列步骤的算法，每一步骤都是带有预定义输入和特定输出的一个过程，把这些步骤串联在一起可产生合理的稳定的贯通于整个程序的控制流。这将最终导致一个很简单的具有静态结构的体系结构。<BR>
  　在结构化开发方法中，数据结构是应算法步骤的要求而开发的。数据结构贯穿于过程，提供过程需要传送给它的操作的信息。系统的状态是一组全局变量，这组全局变量保持了状态的值，把它们从一个过程传送到另一个过程。<BR>
  　结构化开发方法是一种成熟的应用开发过程。对这种方法已经存在许多支持。然而，在大型系统的开发上和在面向用户系统的构造上存在一些问题。改进大型系统开发的技术主要集中在开发数据抽象。日益增多的考虑是使用抽象数据类型，把过程化系统开发过程包括到数据驱动的方法中。随着大型系统的开发，接踵而来的问题就是要把过程抽象与数据抽象方法组合起来，这种需要导致了面向对象开发方法的诞生。<BR>
  　面向对象开发方法是我们分解问题所使用方法演化的结果。在结构化开发方法中过程抽象是优先的，而面向对象开发方法中优先的是实体，即问题论域的对象。在面向对象开发方法中，把标识和模型化问题论域中的主要实体做为系统开发的起点，主要考虑对象的行为而不是必须执行的一系列动作。<BR>
  　面向对象系统中的对象是数据抽象与过程抽象的一个混合体。表示这些实体的数据抽象是面向对象设计过程的主要产品，系统的状态保存在各个数据抽象的核心所定义的数据存储中。控制流被分成块，并被包括在各个在数据抽象上的各个操作里面。不像在结构化开发方法里那样，把数据从一个过程传送到另一个过程，而是控制流从一个数据抽象被传送到另一个数据抽象。完成的系统体系结构更复杂但也更灵活。在块中分离的控制流允许把复杂的动作视为局部的相互影响。</P>
<P class="text"><span class="part">7、解答：</span>论域分析是软件开发方法中一个基本组成部分，它给出的一组抽象是论域的知识的高层表示，用来做为特定系统需求开发的参考。由于分析常常是在超出当前应用的范围进行的，所以这个技术仅在扩充当前系统或将来建立其它系统时找寻复用信息时才是实用的。<BR>
  　论域分析是对与应用开发问题有关的范围十分广泛的知识的学习。论域的边界是模糊的，它们很多是凭借经验和实际考虑（如可用资源）定义的。主要思想是想把考虑的领域放宽一些，把相关的概念都标识到，以帮助更好地掌握应用的核心知识。当用户改变他们对系统需求的想法时，范围广泛的分析可以帮助预测这些变化，并不再需要进一步的分析。<BR>
  　论域分析的目的是标识基本概念，识别论域的特征，把这些概念集成到论域的模型中。这个模型必须包含概念之间的关系和关于每个单独概念的完全信息。这个信息起着一种胶合作用，把所有相关概念并入论域综合视图中去。<BR>
  　论域分析是一个持续的活动，它可以在软件开发的任一时刻进行标识，它还是一个可在超出特定应用的开发范围时仍然能够正常继续的处理。当论域变化时，必须更新那些抽象和关系。论域分析的结果使得我们可积累更多的有关论域的经验和细化我们的抽象。<BR>
  　使用论域抽象做为系统开发基础的好处是可适应性，客户可能改变需求，而且问题环境也可能改变。基于论域信息的应用更容易适应论域内知识的改变和用户需求的变化。<BR>
  　论域分析是一个长期的投资。如果在初始开发时需求发生变化，它可能有更直接的效益；在很大的项目上可能更快地得到回报。最大的价值是抽象的开发，这些抽象表示了一个问题论域中的基本概念，它们形成的软件库还可支持许多应用的开发。<BR>
  　应用(或系统)分析细化在论域分析阶段所开发出来的信息，并且把注意力集中于要解决的精确的问题。应当把客户对系统的需求当做限制来使用，它们缩减了论域的信息量，而这种信息将是主动设计过程的一部分。就这一点来说，保留的信息受到论域分析视野的影响。论域分析产生的模型并不需要用任何基于计算机系统的程序设计语言来表示，而应用分析阶段产生影响的条件则伴随着某种基于计算机系统的程序设计语言的表示。响应时间需求、用户界面需求和某些特殊的需求，如数据安全等，在这一层都被分解提取。<BR>
  　许多模型识别的要求是针对不止一个应用的。通常我们着重考虑两个方面：应用视图和类视图。必须对每个类的规格说明和操作详细化，还必须对形成应用结构的类之间的相互作用加以表示。</P>
<P class="text"><span class="part">8、解答：</span>UML叫做统一的建模语言，它把Booch、Rumbaugh和Jacobson等各自独立的OOA和OOD方法中最优秀的特色组合成一个统一的方法。UML允许软　件工程师使用由一组语法的语义的实用的规则支配的符号来表示分析模型。<BR>
  　在UML中用5种不同的视图来表示一个系统，这些视图从不同的侧面描述系统。每一个视图由一组图形来定义。这些视图概述如下：<BR>
  　・用户模型视图 ：这个视图从用户(在UML中叫做参与者)角度来表示系统。它用使用实例(use case)来建立模型，并用它来描述来自终端用户方面的可用的场景。<BR>
  　・结构模型视图 ：从系统内部来看数据和功能性。即对静态结构(类、对象和关系)模型化。<BR>
  　・行为模型视图 ：这种视图表示了系统动态和行为。它还描述了在用户模型视图和结构模型视图中所描述的各种结构元素之间的交互和协作。<BR>
  　・实现模型视图 ：将系统的结构和行为表达成为易于转换为实现的方式。<BR>
  　・环境模型视图 ：表示系统实现环境的结构和行为。<BR>
  　通常，UML分析建模的注意力放在系统的用户模型和结构模型视图，而UML设计建模则定位在行为模型、实现模型和环境模型。</P>
<P><span class="part">9、解答：</span><BR>
  <IMG alt="" hspace=0 src="image/06.gif" align=baseline border=0><BR>
  <BR>
  <span class="text">　一个典型的高层设计是在Smalltalk中使用的MVC软件体系结构，即模型／视图／控制器(Model／View／Controller)。在这个结构中，模型是软件中的应用论域的各种对象，它们的操作独立于用户界面；视图则管理用户界面的输出；而控制器处理软件的输入。输入事件给出要发送给模型的消息。一旦模型改变了它的状态，就立即通过关联机制通知视图，让视图刷新显示。这个关联机制定义了在模型与各个视图之间的关系，它允许模型的运行独立于与它相关联的视图。类似地，控制器在输入事件发生时将对视图及模型进行控制与调度。<BR>
  　另一个典型的高层设计是Coad与Yourdon提出的OOD模型。这个模型也有 5 层结构，又被划分成了 4 个组成部分：问题论域、用户界面、任务管理和数据管理。</span><BR>
  <BR>
  <IMG alt="" hspace=0 src="image/07.gif" align=baseline border=0><BR>
  <BR>
  <span class="text">　问题论域部分的职责是：组合所有的论域中定义的类，为应用设计适当的类层次，为适应语言要求简化继承层次，细化设计以改善性能，开发与数据管理部分的接口，做细化时加入低层对象，评审设计并审查对分析模型所做的增补。<BR>
  　人机交互部分的职责是：定义用户类型，开发任务场景，设计用户命令层次，建立原型以细化与用户交互，设计相关的类和类层次，适当时集成GUI类。<BR>
  　任务管理部分的职责是：标识任务的类型(如事件驱动，时钟驱动)，建立优先级，标识协调者，为每个任务设计适当的类。<BR>
  　数据管理部分的职责是：设计数据结构和布局，设计管理数据结构所需的服务，标识可以协助实现数据管理的工具，设计适当的类和类层次。</span></P>
<P class="text"><span class="part">10、解答：</span>在设计类时需要遵循的方针是：<BR>
  　・信息隐蔽：通过信息隐蔽可保护类的存储表示不被其它类的实例直接存取。&nbsp;&nbsp;&nbsp; <BR>
  　・消息限制：该类实例的用户应当只能使用界面提供的操作。&nbsp;<BR>
  　・狭窄界面：只有对其它类的实例是必要的操作才放到界面上。<BR>
  　・强内聚：模块内部各个部分之间应有较强的关系，它们不能分别标识。<BR>
  　・弱耦合：一个单独模块应尽量不依赖于其它模块。<BR>
  　・显式信息传递：两个类之间的交互应当仅涉及显式信息传递。<BR>
  　・派生类当做派生类型：每个派生类应该当做基类的特殊化来开发，而基类所具有的公共界面成为派生类的共有界面的一个子集。<BR>
  　・抽象类：某些语言提供了一个类，用它做为继承结构的开始点，所有用户定义的类都直接或间接以这个类为基类。<BR>
  为了在类的设计中做到抽象、信息隐蔽和模块化：<BR>
  　以类作为系统的基本模块单元，通过一般化�D特殊化关系和整体�D部分关系，搭建整个系统的类层次结构，实现数据抽象和过程抽象；<BR>
  将数据和相关的操作封装在类内部，建立共有、私有和子类型等存取级别，将数据表示定义成为类的私有成员，实现信息隐蔽。<BR>
  通过建立类属性(类模板)，将某些有可复用要求的类设计成在数据类型上通用的可复用的软件构件，这样有助于实现模块化。</P>
<P><span class="part">11、解答：</span><span class="text">在类的通过复用的设计中，主要的继承关系有两大类：<BR>
  　① 配置：利用既存类来设计类，可能会要求由既存类的实例提供类的某些特性。通过把相应类的实例声明为新类的属性来配置新类。例如，一种仿真服务器可能要求使用一个计时器来跟踪服务时间。设计者不必开发在这个行为中所需的数据和操作，而是应当找到计时器类，并在服务器类的定义中声明它。<BR>
  　但如果使用既存类的内部表示来做为新类的内部表示的一部分，这是一种“针对实现”的继承方式，这种继承方式不好。例如，考虑使用继承来实现一个Circle类。Point类可支持Circle类的一部分实现。为了定义一个圆，我们只需要定义一个点和一个值，做为圆的圆心和半径。把Point当做子类，Circle类不但能得到由x和y提供的圆心，而且还能得到一个操作，让圆能够自由移动。但这样做，我们失去了抽象。<BR>
  　② 演变 ：要开发的新类可能与一个既存类非常类似，但不完全相同。此时可以从一个既存类演变成一个新类，可以利用继承机制来表示一般化�D特殊化的关系。特殊化处理有三种可能的方式。</span><BR>
  <BR>
  <IMG alt="" hspace=0 src="image/08.gif" align=baseline border=0 width="391" height="113"></P>
<P class="text">　如果新的概念是一个既存类所表示概念的一个特殊情况，特殊化运算可以从该既存类的定义产生新类的初始构造，这是典型的类继承的使用。既存类A的数据结构和操作可以成为新类B的一部分，如图(a)所示。既存类A的公共操作成为新类B的共有界面部分。<BR>
  　如果新类比软件库中那些既存类更一般，则新类B不具有既存类A的全部特性，一般化运算把两个类中共同的特性移到新的更高层的类中，高一层的类是B，我们将要设计它。原来的类A成为新类B的子类。如图(b)所示。<BR>
  　一个既存类A与我们设计的新类B共享概念的某一个部分，则两个概念的共同部分形成新类的基础，且既存类与新类两者成为子类，如图(c)所示。</P>
<P class="section">五、应用题</P>
<P><span class="part">1、解答：</span><span class="text"><br>
  　・对象模型应由对象图和数据词典组成。根据题意，先给出对象图。<br>
  　・窗口类与对话窗类、图形窗类、滚动窗类是一般化?特殊化关系。<br>
  　・对话窗类与对话项类是限定关联，限定词是对话项名。<br>
  　・对话项类与按钮类、选择项类、正文项类是一般化?特殊化关系。<br>
  　・选择项类与选择项入口类是一对多的拥有关联。<br>
  　・图形窗类与形状元素类也是一对多的拥有关联。<br>
  　・形状元素类与一维形状、二维形状是一般化?特殊化关系。<br>
  　・一维形状类与直线类、圆弧类、折线类是一般化?特殊化关系。<br>
  　・折线类与顶点类是整体-部分关系。<br>
  　・二维形状类与圆类、椭圆类、矩形类、多边形类是一般化?特殊化关系。<br>
  　・多边形类与顶点类是整体-部分关系，一个多边形至少有3个顶点。<br>
  　・正文窗类与滚动窗类是一般化?特殊化关系。<br>
  　・图形滚动窗类的父类是图形窗类和滚动窗类，这是一个多继承关系。<br>
  </span><BR>
  <IMG alt="" hspace=0 src="image/09.gif" align=baseline border=0><BR>
  <span class="text">对应的窗口系统的数据词典</span><BR>
  <BR>
  <IMG alt="" hspace=0 src="image/10.gif" align=baseline border=0><BR>
  <BR>
  <span class="part">2、解答：</span><span class="text">首先建立事件追踪图，用于描述用户与系统的一次交互行为。在图中，按时间的先后次序以及事件的发送和接收顺序，自上而下画出。</span><BR>
  <BR>
  <IMG alt="" hspace=0 src="image/11.gif" align=baseline border=0><BR>
  <span class="text">根据事件追踪图建立的状态图如下：</span><BR>
  <BR>
  <IMG alt="" hspace=0 src="image/12.gif" align=baseline border=0><BR>
</P>


