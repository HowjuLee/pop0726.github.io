<html>
<head>
<title>l1</title>
<meta http-equiv="Content-Type" content="text/html; charset="utf-8"">
<link rel="stylesheet" href="../../../../css/text.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" height="100%">
  <tr>
    <td valign="top">
      <table width="92%" border="0" cellspacing="0" cellpadding="0" align="center" height="8">
        <tr> 
          <td class="text"> 
            <p><br>
              <span class="section">6、显式信息传递</span><br>
              ��除了依赖于最少的类外，还应该明确在这些类之间的信息流。在类之间全局变量的共享隐含了信息的传递，并且是一种依赖形式。因此，两个类之间的交互应当仅涉及显式信息传递。显式信息传递是通过参数表来完成的。<br>
              <br>
              <span class="section">7、派生类当做派生类</span><br>
              ��继承结构的使用是面向对象开发方法的一大特色。每个派生类应该当做基类的特殊化来开发，而基类所具有的公共界面成为派生类的共有界面的一个子集。<br>
              ��C++允许设计者选择类的基类是共有的或私有的。如果基类是共有的，则其共有界面将成为新的派生类的共有界面部分，这表明基类的行为成为派生类的行为部分。这类似于类型与派生类型之间的关系。如果基类是私有的，它的行为将不是继承类的公共行为部分而是实现部分。它的提出是为了提供实现新类的服务。<br>
              <br>
              <span class="section">8、抽象类</span><br>
              ��某些语言提供了一个类，用它做为继承结构的开始点，所有用户定义的类都直接或间接以这个类为基类。Smalltalk提供了一个类Object做为所有类的继承树的根，而C++则支持多重继承结构。每一种结构都包含了一组类，它们是(或应该是)某种概念的特殊化。这个概念应抽象地由结构的根类来表示。因此，每个继承结构的根类应当是目标概念的一个抽象模型。这个抽象模型生成一个类，它不用于产生实例。它定义了一个最小的共有界面，许多派生类可以加到这个界面上以给出概念的一个特定视图。 
              <br>
              ��</p>
            </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
</body>
</html>
