<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<STYLE TYPE="text/css">
<!--
BODY {background-image:   url(../../../images/htmls/Slicebg.jpg);
background-position: right bottom;
background-repeat: no-repeat;
background-attachment: fixed;
}
-->
</STYLE>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset="utf-8"">
<link rel="stylesheet" href="../../../css/style.css" type="text/css">
</head>

<body  leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" height="100%" border="0" cellpadding="0" cellspacing="0">
  <tr> 
    <td valign="top" height="20">&nbsp; </td>
  </tr>
  <tr>
    <td valign="top">
      <table width="92%" border="0" align="center" cellpadding="0" cellspacing="0">
        <tr> 
          <td class="text" valign="top"> 
            <p>　　<font color="#000000">在串行快速排序中，首先根据一个界把所有元素分成两部分，然后对两个部分再分别按照同样的方法递归处理。利用这一点可以进行简单的并行化，方法是把分成的两个子序列分别放到两个处理器上并行完成排序工作，然后每个处理器负责的子序列再分成两个子序列并分到不同的处理器上，如此递归。设对一个长度为n的序列按上述算法进行并行排序需要花费的时间为T(n)，则有<img src="../../../images/img_text/ch06/28.gif" width="124" height="18" align="absmiddle">，因此：<br>
              </font><br>
              　　　　　<img src="../../../images/img_text/ch06/29.gif" width="204" height="100"><br>
              <br>
              　　<font color="#000000">这样算法的开销是：<br>
              　　　　　<img src="../../../images/img_text/ch06/30.gif" width="75" height="23" align="absmiddle"><br>
              <br>
              　　这大于快速排序的平均串行处理时间<img src="../../../images/img_text/ch06/26.gif" width="59" height="18" align="absmiddle">。可见这种算法没有充分利用处理器的潜力。</font></p>
            </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
</body>
</html>
