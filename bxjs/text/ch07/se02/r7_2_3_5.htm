<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<STYLE TYPE="text/css">
<!--
BODY {background-image:   url(../../../images/htmls/Slicebg.jpg);
background-position: right bottom;
background-repeat: no-repeat;
background-attachment: fixed;
}
-->
</STYLE>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset="utf-8"">
<link rel="stylesheet" href="../../../css/style.css" type="text/css">
</head>

<body  leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" height="100%" border="0" cellpadding="0" cellspacing="0">
  <tr> 
    <td valign="top" height="20">&nbsp; </td>
  </tr>
  <tr>
    <td valign="top">
      <table width="92%" border="0" align="center" cellpadding="0" cellspacing="0">
        <tr> 
          <td class="text" valign="top"> 
            <p>　<b>　归约</b></p>
            <p>　　MPI_REDUCE( sendbuf, recvbuf, count, datatype, op, root, comm 
              )<br>
              　　IN sendbuf 发送缓冲区起始地址（待归约数据）<br>
              　　OUT recvbuf 接收缓冲区起始地址（root中存放最后结果的地址）<br>
              　　IN count 发送缓冲区中的数据个数（归约数组的长度）<br>
              　　IN datatype 归约的数据类型<br>
              　　IN op 归约操作类型<br>
              　　IN root 根处理器<br>
              　　IN comm 通信域</p>
            <p>　　int MPI_Reduce( void *sendbuf, void *recvbuf, int count, <br>
              　　MPI_Datatype datatype, MPI_Op op, int root, MPI_Comm comm )；</p>
            <p>　　MPI预定义的归约操作类型如下：</p>
            <table width="100%" border="0" cellspacing="1" cellpadding="0" bgcolor="#000000">
              <tr bgcolor="#CCCCCC"> 
                <td rowspan="2" class="text"> 
                  <div align="center"><b>归约操作</b></div>
                </td>
                <td rowspan="2" class="text"> 
                  <div align="center"><b>含义</b></div>
                </td>
                <td width="40%" class="text"> 
                  <div align="center"><b>允许的数据类型</b></div>
                </td>
              </tr>
              <tr> 
                <td width="40%" class="text" bgcolor="#CCCCCC"> 
                  <div align="center"><b>C</b></div>
                </td>
              </tr>
              <tr bgcolor="#FFFFFF"> 
                <td width="30%" class="text"> 
                  <div align="center">MPI_MAX</div>
                </td>
                <td width="30%" class="text"> 
                  <div align="center">最大值</div>
                </td>
                <td width="40%" class="text"> 
                  <div align="center">整型，浮点型</div>
                </td>
              </tr>
              <tr bgcolor="#FFFFFF"> 
                <td width="30%" class="text"> 
                  <div align="center">MPI_MIN</div>
                </td>
                <td width="30%" class="text"> 
                  <div align="center">最小值</div>
                </td>
                <td width="40%" class="text"> 
                  <div align="center">整型，浮点型</div>
                </td>
              </tr>
              <tr bgcolor="#FFFFFF"> 
                <td width="30%" class="text"> 
                  <div align="center">MPI_SUM</div>
                </td>
                <td width="30%" class="text"> 
                  <div align="center">和</div>
                </td>
                <td width="40%" class="text"> 
                  <div align="center">整型，浮点型</div>
                </td>
              </tr>
              <tr bgcolor="#FFFFFF"> 
                <td width="30%" class="text"> 
                  <div align="center">MPI_PROD</div>
                </td>
                <td width="30%" class="text"> 
                  <div align="center">积</div>
                </td>
                <td width="40%" class="text"> 
                  <div align="center">整型，浮点型</div>
                </td>
              </tr>
              <tr bgcolor="#FFFFFF"> 
                <td width="30%" class="text"> 
                  <div align="center">MPI_LAND</div>
                </td>
                <td width="30%" class="text"> 
                  <div align="center">逻辑与</div>
                </td>
                <td width="40%" class="text"> 
                  <div align="center">整型</div>
                </td>
              </tr>
              <tr bgcolor="#FFFFFF"> 
                <td width="30%" class="text"> 
                  <div align="center">MPI_BAND</div>
                </td>
                <td width="30%" class="text"> 
                  <div align="center">按位与</div>
                </td>
                <td width="40%" class="text"> 
                  <div align="center">整型，字节型</div>
                </td>
              </tr>
              <tr bgcolor="#FFFFFF"> 
                <td width="30%" class="text"> 
                  <div align="center">MPI_LOR</div>
                </td>
                <td width="30%" class="text"> 
                  <div align="center">逻辑或</div>
                </td>
                <td width="40%" class="text"> 
                  <div align="center">整型</div>
                </td>
              </tr>
              <tr bgcolor="#FFFFFF"> 
                <td width="30%" class="text"> 
                  <div align="center">MPI_BOR</div>
                </td>
                <td width="30%" class="text"> 
                  <div align="center">按位或</div>
                </td>
                <td width="40%" class="text"> 
                  <div align="center">整型，字节型</div>
                </td>
              </tr>
              <tr bgcolor="#FFFFFF"> 
                <td width="30%" class="text"> 
                  <div align="center">MPI_LXOR</div>
                </td>
                <td width="30%" class="text"> 
                  <div align="center">逻辑异或</div>
                </td>
                <td width="40%" class="text"> 
                  <div align="center">整型</div>
                </td>
              </tr>
              <tr bgcolor="#FFFFFF"> 
                <td width="30%" class="text"> 
                  <div align="center">MPI_BXOR</div>
                </td>
                <td width="30%" class="text"> 
                  <div align="center">按位异或</div>
                </td>
                <td width="40%" class="text"> 
                  <div align="center">整型，字节型</div>
                </td>
              </tr>
              <tr bgcolor="#FFFFFF"> 
                <td width="30%" class="text"> 
                  <div align="center">MPI_MAXLOC</div>
                </td>
                <td width="30%" class="text"> 
                  <div align="center">第一个最大值</div>
                </td>
                <td width="40%" class="text"> 
                  <div align="center">专用类型</div>
                </td>
              </tr>
              <tr bgcolor="#FFFFFF"> 
                <td width="30%" class="text"> 
                  <div align="center">MPI_MINLOC</div>
                </td>
                <td width="30%" class="text"> 
                  <div align="center">第一个最小值</div>
                </td>
                <td width="40%" class="text"> 
                  <div align="center">专用类型</div>
                </td>
              </tr>
            </table>
            <br>
            　　其中的整型包括：<br>
            　　MPI_INT MPI_UNSIGNED<br>
            　　MPI_SHORT MPI_UNSIGNED_SHORT<br>
            　　MPI_LONG MPI_UNSIGNED_LONG<br>
            　　<br>
            　　浮点型包括<br>
            　　MPI_FLOAT<br>
            　　MPI_DOUBLE<br>
            　　MPI_LONG_DOUBLE<br>
            <br>
            　　字节型为MPI_BYTE<br>
            　　专用类型是专门为这两个操作定义的,请参照MPI规范中对应的说明。 
            <p>　　顺便提一句，除了这些预定义归约操作类型外，MPI允许用户自定义归约操作类型，对应的操作为MPI_OP_CREATE和MPI_OP_FREE。用户需要保证这个归约操作满足结合律，但不要求可交换性。<br>
              <br>
              　　<font color="#000000">一个经典的例子。求π值。<br>
              　　这种方法所依赖的原理如下式：<br>
              　　<img src="../../../images/img_text/ch07/4.gif" width="356" height="41"><br>
              <br>
              　　所以π值可以转化为求函数<img src="../../../images/img_text/ch07/5.gif" width="44" height="41" align="absmiddle">在[0，1]区间与x轴所夹图形的面积。可以用下面的公式来逼近这个面积：<br>
              　　<img src="../../../images/img_text/ch07/6.gif" width="268" height="45"><br>
              　　可以证明，通过增大N，可以以任意精度逼近π值。</font></p>
            <p><font color="#000000">　　程序如下（原例子由MPICH-1.2.3的例子cpi.c给出， /* */中为原文给出的注释<br>
              　　//后面的是本文中所加得注释，它们可以被安全的删除）：</font></p>
            <p><font color="#000000">　　//pi.c<br>
              　　//使用mpicc -o pi pi.c进行编译<br>
              　　//使用mpirun -np 4 pi来运行（四个处理器）<br>
              　　#include &quot;mpi.h&quot;<br>
              　　#include &lt;stdio.h&gt;<br>
              　　#include &lt;math.h&gt;</font></p>
            <p><font color="#000000">　　// 计算出a点处函数f(x)=<img src="../../../images/img_text/ch07/5.gif" width="44" height="41" align="absmiddle">的值<br>
              　　double f(double a)<br>
              　　{<br>
              　　　return (4.0 / (1.0 + a*a));<br>
              　　}</font></p>
            <p><font color="#000000">　　int main(int argc,char **argv)<br>
              　　{<br>
              　　　int done = 0, n, myid, numprocs, i;<br>
              　　　//25位的PI的参考值<br>
              　　　double PI25DT = 3.141592653589793238462643;<br>
              　　　double mypi, pi, h, sum, x;<br>
              　　　double startwtime = 0.0, endwtime;<br>
              　　　int namelen;<br>
              　　　char processor_name[MPI_MAX_PROCESSOR_NAME];</font></p>
            <p><font color="#000000"> 　　　MPI_Init(&amp;argc,&amp;argv);<br>
              　　　MPI_Comm_size(MPI_COMM_WORLD,&amp;numprocs);<br>
              　　　MPI_Comm_rank(MPI_COMM_WORLD,&amp;myid);<br>
              　　　MPI_Get_processor_name(processor_name,&amp;namelen);</font></p>
            <p><font color="#000000"> 　　　fprintf(stdout,&quot;Process %d of %d 
              on %s\n&quot;,<br>
              　　　　myid, numprocs, processor_name);</font></p>
            <p><font color="#000000"> 　　　n = 0;<br>
              　　　while (!done)<br>
              　　　{<br>
              　　　　if (myid == 0)<br>
              　　　　{<br>
              　　/*<br>
              　　　　　printf(&quot;Enter the number of intervals: (0 quits) &quot;);<br>
              　　　　　scanf(&quot;%d&quot;,&amp;n);<br>
              　　*/<br>
              　　　　//设定N值，注意，用上面的两个语句，可以由用户给出N值<br>
              　　　　if (n==0) n=10000; else n=0;<br>
              　　　　//进程0开始计时<br>
              　　　　startwtime = MPI_Wtime();<br>
              　　　　}<br>
              　　　　//由进程0广播N值<br>
              　　　　MPI_Bcast(&amp;n, 1, MPI_INT, 0, MPI_COMM_WORLD);<br>
              　　　　if (n == 0)<br>
              　　　　　done = 1;<br>
              　　　　else<br>
              　　　　{<br>
              　　　　　//h是区间的步长<br>
              　　　　　h = 1.0 / (double) n;<br>
              　　　　　sum = 0.0;<br>
              　　　/* A slightly better approach starts from large i and works back 
              */<br>
              　　　　//注意每个处理器都通过myid来确定自己的工作。<br>
              　　　　for (i = myid + 1; i &lt;= n; i += numprocs)<br>
              　　　　{<br>
              　　　　　//x是每个区间的中点的x坐标<br>
              　　　　　x = h * ((double)i - 0.5);<br>
              　　　　　//sum现在包含的是每个处理器上的局部和<br>
              　　　　　sum += f(x);<br>
              　　　　}<br>
              　　　　//得到了局部的面积,为了减少不必要的计算，从上面的循环中提了出来。<br>
              　　　　mypi = h * sum;</font></p>
            <p><font color="#000000"> 　　　　//由局部的面积得到总的面积<br>
              　　　　MPI_Reduce(&amp;mypi, &amp;pi, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);</font></p>
            <p><font color="#000000"> 　　　　//由进程0打印结果，误差和计算时间。<br>
              　　　　if (myid == 0)<br>
              　　　　{<br>
              　　　　　printf(&quot;pi is approximately %.16f, Error is %.16f\n&quot;,<br>
              　　　　　　　　pi, fabs(pi - PI25DT));<br>
              　　　　　endwtime = MPI_Wtime();<br>
              　　　　　printf(&quot;wall clock time = %f\n&quot;, endwtime-startwtime);	
              <br>
              　　　　　fflush( stdout );<br>
              　　　　}<br>
              　　　}<br>
              　　}<br>
              　　MPI_Finalize();<br>
              　　return 0;<br>
              　}</font></p>
            </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
</body>
</html>
