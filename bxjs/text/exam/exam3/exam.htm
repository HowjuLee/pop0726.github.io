<html>
<head>
<title>考试试题</title>
<meta http-equiv="Content-Type" content="text/html; charset="utf-8"">
<link rel="stylesheet" href="css/text.css" type="text/css">
<STYLE TYPE="text/css">
<!--
BODY {background-image:   url(../../../images/htmls/Slicebg.jpg);
background-position: right bottom;
background-repeat: no-repeat;
background-attachment: fixed;
}
-->
</STYLE>

<script language="JavaScript">
<!--
function MM_openBrWindow(theURL,winName,features) { //v2.0
  window.open(theURL,winName,features);
}
//-->
</script>
</head>
<script language="JavaScript">
function getresultcheck(form)
{var mykeys=new Array();
//  mykeys[0]="B";
//czp-select-answer
var answer=new Array();
for(var I=0;I<mykeys.length;I++) answer[I]="";

var every=form.elements;

<!--czp-select-count-->
for(var I=0;I<every.length;I++)
{
	if(every[I].type=="radio")
	{
		
		if(every[I].checked)
		{	
	
			var item=parseInt(every[I].name.substr(0));
		
			answer[item-1]+=every[I].value;
		}
	}				
}

var newcount="<html><head><title>谢谢您!</title></head><body><center><h2><font color=red>您的测试结果</font></h2></center>";
var totalscore=0;
for(var I=0;I<answer.length;I++)
{
	if(answer[I]==mykeys[I])
	{
		var rstr="<font size=2>第"+(I+1)+"题答案正确!</font><br>";
		newcount+=rstr;
		totalscore+=1/(answer.length)*100;//每题分数
	}else
	{
		var rstr="<font size=2>第"+(I+1)+"题答案错误!正确答案为"+mykeys[I]+"</font><br>";
		newcount+=rstr;
	}

}

newcount+="<br>您的总成绩为:";
newcount+=Math.ceil(totalscore);
newcount+="分";
newwin=window.open("","","height=200,width=300,scrollbars=yes,resizable=no");
newwin.document.write(newcount);}



function getresultcheck1(form)
{var mykeys=new Array();
//  mykeys[0]="B";
//czp-mulselect-answer
var answer=new Array();
for(var I=0;I<mykeys.length;I++) answer[I]="";

var every=form.elements;

<!--czp-mulselect-count-->
for(var I=0;I<every.length;I++)
{
	if(every[I].type=="checkbox")
	{
		
		if(every[I].checked)
		{	
	
			var item=parseInt(every[I].name.substr(0));
		
			answer[item-1]+=every[I].value;
		}
	}				
}

var newcount="<html><head><title>谢谢您!</title></head><body><center><h2><font color=red>您的测试结果</font></h2></center>";
var totalscore=0;
for(var I=0;I<answer.length;I++)
{
	if(answer[I]==mykeys[I])
	{
		var rstr="<font size=2>第"+(I+1)+"题答案正确!</font><br>";
		newcount+=rstr;
		totalscore+=1/(answer.length)*100;//每题分数
	}else
	{
		var rstr="<font size=2>第"+(I+1)+"题答案错误!正确答案为"+mykeys[I]+"</font><br>";
		newcount+=rstr;
	}

}

newcount+="<br>您的总成绩为:";
newcount+=Math.ceil(totalscore);
newcount+="分";
newwin=window.open("","","height=200,width=300,scrollbars=yes,resizable=no");
newwin.document.write(newcount);}












function check(){
var mykeys=new Array();
//czp-tiankong-answer
//mykeys[0]="B";
var answer=new Array();
for(var I=0;I<mykeys.length;I++) answer[I]="";

var every=zfl.elements;
for(var I=0;I<every.length;I++)
{
if(every[I].type=="text")
{
 if(every[I].value!==null)
 {
 //var item=parseInt(every[I].name.substr(1))
//  answer[item-1]+=every[I].value;
  answer[I]+=every[I].value;
  }
 }
}


var newcount="<html><head><title>谢谢您!</title></head><body><center><h2><font face=\"隶书\" size=\"5\" color=\"#000099\">您的测试结果</font></h2></center>";
var totalscore=0;
for(var i=0;i<answer.length;i++)
{
	if(answer[i]==mykeys[i])
	{
		var rstr="<font face=\"宋体\" size=2>第"+(i+1)+"个空答案正确!</font><br>";
		newcount+=rstr;
		totalscore+=1/(answer.length)*100;
	}else
	{
		var rstr="<font face=\"宋体\" size=2>第"+(i+1)+"个空答案错误!正确答案为"+mykeys[i]+"</font><br>";
		newcount+=rstr;
	}

}

newcount+="<br><font face=\"宋体\" size=3><b>您的总成绩为:</b></font><font face=\"宋体\" size=3 color=red>";
newcount+=Math.ceil(totalscore);
newcount+="分</font><br>";
newwin=window.open("","","height=400,width=400,scrollbars=yes,resizable=no");
newwin.document.write(newcount);
}

</script>
<body bgcolor="#FFFFFF" text="#000000" topmargin=0>

<center>
  <br>
  <span class="part">考试试题三</span><br>
  <br>
  <table width="95%" border="0" cellspacing="0" cellpadding="0">
  <tr>
      <td class=text> 
        <form>
         
          </form>
 
        <form>
          
          </form>
 
 
 
        <form name="zfl">
       
          </form>
          <form>
          <p> <br>
            一、 名词解释（20分，每小题四分）<br>
            　　MPP<br>
            　　NUMA <br>
            　　PRAM <br>
            　　同步 <br>
            　　任务并行性 <br>
            <br>
            <textarea name=jianda cols=50 rows=5></textarea>
            <br>
            <br>
            <br>
            二、 （16分）求下图所示Iliac网当结点数为N时，网络的链路条数、直径、对分宽度。 <br>
            <center>
              　 <img src="images/st3_1.gif" width="214" height="196" vspace="5"> 
            </center>
            <br>
            <textarea name=jianda cols=50 rows=5></textarea>
            <br>
            <br>
            <br>
            三、（16分）考虑如下的PRAM-EREW模型：p个处理器，m个存储器。我们可以在一个p个处理器，每个处理器有m/p个存储器的消息传递结构的并行计算机上模拟这个模型。如果一个算法在这种PRAM-EREW上的运行时间是t，请给出这个算法在下面的体系结构上的运行时间上限： 
            <br>
            　　(1) p处理器的环（ring） <br>
            　　(2) p处理器的二维网格（mesh） <br>
            　　(3) p处理器的超立方体（hypercube） <br>
            <br>
            <textarea name=jianda cols=50 rows=5></textarea>
            <br>
            <br>
            <br>
            四、（16分）在p个处理器的超立方体上完成n个数的加法（p < n，其中p和n都是2的整数次幂），使用的方法如下图（n=16和p=4时的解题过程） 
            <br>
            <center>
              　<img src="images/st3_2.gif" width="265" height="248" vspace="5"> 
            </center>
            证明上述使用的算法为开销最优的。<br>
            <br>
            <textarea name=jianda cols=50 rows=5></textarea>
            <br>
            <br>
            <br>
            五、对n×n矩阵，在具有p个处理器的超立方体互联结构上实现矩阵转置。基本思路是先将一个n×n的矩阵先分成4个子矩阵，把每个子矩阵看作一个整体对整个大矩阵进行转置；然后每个子矩阵再分成4个更小的矩阵，逐次递归，最后实现了矩阵的转置。分析算法总的运行时间。<br>
            <br>
            <textarea name=jianda cols=50 rows=5></textarea>
            <br>
            <br>
            <br>
            六、对于一个赋权图G=(V, E, w)和图G任意一点v，寻找v到图G中其它各点的最短路，最终结果是一个向量。Dijkstra算法是解决一点到其它各点最短路的常用方法，算法如下：<br>
            　1． procedure DIJKSTRA_SINGLE_SOURCE_SP(V,E,w,s)<br>
            　2． begin <br>
            　3． 　V<sub>T</sub>:={s};<br>
            　4． 　for all v∈(V-V<sub>T</sub>) do<br>
            　5． 　　if (s,v) exists set l[v]:=w(s,v);<br>
            　6． 　　else set l[v]=∞;<br>
            　7． 　while V<sub>T</sub>≠V do<br>
            　8．　 begin <br>
            　9． 　　find a vertex u such that l［u］=min{l[v]|v∈(V-V<sub>T</sub>)};<br>
            　10． 　　V<sub>T</sub>:=V<sub>T</sub>∪{u};<br>
            　11． 　　for all v∈(V-V<sub>T</sub>) do<br>
            　12． 　　　l[v]=min{l[v],l[u]+w(u,v)};<br>
            　13． 　endwhile<br>
            　14． end DIJKSTRA_SINGLE_SOURCE_SP<br>
            <br>
            　　请给出求解一点到其它各点最短路的并行算法在超立方体上的并性性能分析。 <br>
            <br>
            <textarea name=jianda cols=50 rows=5></textarea>
            <br>
            <br>
            <br>
            <!--czp-wenda-timu-->
            <br>
            <input type=button name=Button value=答案 案 onClick="MM_openBrWindow('text/examination/exam01_pop2.htm','','width=471,height=384')" class=pbox>
            <input type='reset' name='Submit3' value='重置' class=pbox>
            <br>
          </p>
          </form>
        <form>
         
        </form>
        <form>
        </form>
      </td>
  </tr>
</table></center>

</body>
</html>
