<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<link rel="stylesheet" href="../../css/text.css" type="text/css">
<style type="text/css">
<!--
.bodybg {
	background-attachment: fixed;
	background-repeat: no-repeat;
	background-position: right bottom;
}
-->
</style></head>

<body class="bodybg" bgcolor="#FFFFFF" background="../../../../../images/htmls/openwin/bg.jpg" text="#000000" leftmargin="0" topmargin="0" rightmargin="0" bottommargin="0" marginwidth="0" marginheight="0" >
<center><table width="95%" border="0" cellspacing="0" cellpadding="0">
  <tr>
      <td class=text> <p>第一题<br>
          DSM <br>
          　　分布式共享存储器多处理机. 主要特点是它的存储器在物理上是分布在各个结点中的，但是通过硬件和软件为用户提供一个单一地址的编程空间，即形成一个虚拟的共享存储器。它通过高速缓存目录支持分布高速缓存的一致性。<br>
          <br>
          COMA <br>
          　　COMA是全高速缓存存储结构模型的缩写。COMA实际是NUMA的一种特例，将NUMA中的分布存储器换成高速缓存就得到了COMA。在COMA中，每个结点上没有存储层次结构，所有的高速缓存构成了全局地址空间。访问远程高速缓存要借助分布的高速缓存目录。<br>
          <br>
          总线 <br>
          　　总线（Bus）实际上是连接处理器、存储器和I/O等外围设备的一组导线和插座。总线的一个特点是：它在某一时刻只能用于一对源和目的之间传输数据。当有多对源和目的请求使用总线时，必须由总线仲裁逻辑进行总线仲裁，即确定先为哪一对源和目的服务。<br>
          <br>
          虫蚀寻径 <br>
          　　虫蚀寻径是寻径的一种方式。包被分成更小的片进行传输，头片包含了这个包的所有寻径信息，其它片是数据片。与结点相连的硬件寻径器中有片缓冲区。同一个包中所有的片像不可分离的同伴一样以流水方式顺序地传送。<br>
          <br>
          LogP模型<br>
          　　LogP模型是一种分布存储的、点到点通信的多处理机模型，其中通信网络由4个主要参数来描述：L(Latency) 表示源处理机与目的处理机进行消息（一个或几个字）通信所需要的等待或延迟时间的上限；o(overhead)表示处理机准备发送或接收每个消息的时间开销；g(gap)表示一台处理机连续两次发送或接收消息时的最小时间间隔；P(Processor)处理机/存储器模块个数 
          <br>
          <br>
          第二题<br>
          第11号处理器的二进制地址为01011 。<br>
          （1）<img src="../../images/st2_7.gif" width="129" height="15" align="absmiddle"> 
          ，因此当互连函数为<img src="../../images/st2_8.gif" width="33" height="15" align="absmiddle"> 
          时，第11号处理器与第3号处理器相连。 <br>
          （2）<img src="../../images/st2_9.gif" width="104" height="14" align="absmiddle"> 
          ，因此当互连函数为均匀洗牌时，第11号处理器与第22号处理器相连。 <br>
          （3）<img src="../../images/st2_10.gif" width="115" height="17" align="absmiddle"> 
          ，因此当互连函数为逆均匀洗牌时，第11号处理器与第21号处理器相连。 <br>
          （4）<img src="../../images/st2_11.gif" width="105" height="14" align="absmiddle"> 
          ，因此当互连函数为蝶式置换时，第11号处理器与第26号处理器相连。<br>
          <br>
          第三题<br>
          （1） 略（可以参见下面的例子） <br>
          （2） 算法过程相当于二叉树形归约，树形算法的复杂度为logn，所以算法的时间复杂度为<img src="../../images/st2_12.gif" width="50" height="14" align="absmiddle">，从上面算法描述中也可以看出，外层循环是串行的，有logn个循环步，内层循环是并行的，平均只需要一个（两个？）单位时间，所以由此也可以看出，算法的时间复杂度为<img src="../../images/st2_13.gif" width="50" height="14" align="absmiddle">。 
          <br>
          <br>
          第四题<br>
          　　首先考虑在n处理器的超立方体上，完成n个数的和。然后采用p个处理器来模拟n个处理器的算法。下面的图描述了n=16和p=4时的解题过程<br>
          <img src="../../images/st2_15.gif" width="420" height="888"><br>
          <img src="../../images/st2_14.gif" width="423" height="454"> <br>
          　　虚拟处理器j（从0开始编号）用标号为j mod p的物理处理器来模拟。原算法的logn个步骤中的前logp个步骤由p个处理器进行仿真，共(n/p)logp个步骤，在其余的步骤中，不再进行通信，因为需要通信的虚拟处理器现在都由同一个物理处理器进行仿真，因此，剩下的数据都在局部进行计算。这个算法需要<img src="../../images/st2_16.gif" width="91" height="14" hspace="1" vspace="2" align="absmiddle">个通信步骤，这以后，一个处理器需要将n/p个数据进行累加，这需要<img src="../../images/st2_17.gif" width="48" height="14" hspace="1" vspace="2" align="absmiddle">个时间步，因此，这个并行系统的总的并行运行时间为<img src="../../images/st2_18.gif" width="91" height="14" hspace="1" vspace="2" align="absmiddle">，而开销为<img src="../../images/st2_19.gif" width="63" height="14" hspace="1" vspace="2" align="absmiddle">，这要比串行的累加n个数的开销<img src="../../images/st2_20.gif" width="29" height="14" hspace="1" vspace="2" align="absmiddle">要高，因此，这个并行系统并不是开销最优的。 
          <br>
          <br>
          第五题<br>
          　　将树的节点如下的编号： <br>
          <img src="../../images/st2_21.gif" width="350" height="200"><br>
          　　串行搜索算法的节点访问顺序为：<br>
          　　1→2→4→8→4→9→4→2→5→10→5→11→5→2→1→3→6→12→6→13 <br>
          　　共需要访问19个弧，搜索时间为19个单位时间； <br>
          　　并行搜索时，<br>
          　　第一个处理器的搜索顺序为：<br>
          　　1→2→4→8→4→9→4→2→5→10→5→11 <br>
          　　第二个处理器的搜索顺序为：<br>
          　　1→3→6→12→6→13 <br>
          　　假设两个处理器速度相当，那么，5个单位时间后，第二个处理器已经找到了解，并行算法顺利结束，此时并行算法的加速比为 <br>
          <center>
            　 <img src="../../images/st2_22.gif" width="98" height="32" align="absmiddle"> 
          </center>
          　　表现出超线性加速比。出现超线性加速比的原因是并行搜索时的问题规模实际上比串行搜索时的问题规模减小了，所以出现了超线性加速比。<br>
          <br>
          第六题<br>
          　　这是一个问题规模固定的加速比问题，所以是Amdahl定律讨论的范围。 根据Amdahl定律，这个系统的加速比可以表示成下面的公式 <br>
          <center>
            　<img src="../../images/st2_23.gif" width="134" height="36" vspace="5" align="absmiddle"> 
          </center>
          
          　　随着p的增大，这是一个递增的函数，但这个函数有上限，当<img src="../../images/st2_24.gif" width="44" height="10" hspace="3" align="absmiddle">时，有<br>
          <center>
            　<img src="../../images/st2_5F25.gif" width="80" height="36" vspace="5" align="absmiddle"> 
          </center>
          　　这就是这个并行系统的加速比上限，在讨论Amdahl定律时实际上已经讨论过，固定规模的问题得加速比的极限由问题的串行部分比例f确定，它就等于1/f，上面的答案和这个结论是一致的。 
          <br>
          <!--czp-wenda-daan-->
          <br>
          <br>
          　</p>
        </td>
  </tr>
</table>
  </center>

</body>
</html>
