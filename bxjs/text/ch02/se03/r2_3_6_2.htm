<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<STYLE TYPE="text/css">
<!--
BODY {background-image:   url(../../../images/htmls/Slicebg.jpg);
background-position: right bottom;
background-repeat: no-repeat;
background-attachment: fixed;
}
-->
</STYLE>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset="utf-8"">
<link rel="stylesheet" href="../../../css/style.css" type="text/css">
</head>

<body  leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" height="100%" border="0" cellpadding="0" cellspacing="0">
  <tr> 
    <td valign="top" height="20">&nbsp; </td>
  </tr>
  <tr>
    <td valign="top">
      <table width="92%" border="0" align="center" cellpadding="0" cellspacing="0">
        <tr> 
          <td class="text" valign="top"> 
            <p>　　<b>Cache一致性策略</b><br>
              <br>
              　　通常使用两种策略来解决Cache一致性问题：写无效策略和写更新策略。写无效策略（write invalidate）是指当某个处理器更新其私有Cache中的某个数据时，它通知所有其它Cache这一数据在它们中的副本从此均无效。这样就可以避免其它&quot;过时&quot;的副本被使用而造成错误。写更新策略（write 
              update）是指当某个处理器更新其私有Cache中的某个数据时，它把所更新的数据发送给所有的其它Cache，以更新这一数据在其它Cache中的所有副本。一般来说，使用写更新策略，需要传输更新后的数据，而写无效只需传输写无效信息，因此写更新传输的数据量比写无效要大。而且，被更新的数据的某些副本以后也不一定再被使用。例如上图中，P<sub>1</sub>更新X后，P<sub>2</sub>不一定再使用变量X的值。因此每次都对所有的副本都更新是没有必要的。请注意，写无效和写更新是维护Cache一致性的策略，它与维护Cache与主存储器一致性的策略没有必然的关系。无论是使用写无效策略还是写更新策略，共享存储器中的数据副本都可以通过写直达或写回策略来维护与Cache的一致性。例如，如果采用写无效策略和写直达策略，当处理器P修改私有Cache中的某一数据时，不但要向其它处理器的Cache发送无效信息，而且要将共享存储器中该数据的副本更新。最终，处理器P的私有Cache和共享存储器中的数据是相同而且是正确的，而其它处理器Cache中该数据的副本被标记为无效。如果采用写无效策略和写回策略，当处理器P修改私有Cache中的某一数据时，不但要向其它处理器的Cache发送无效信息，而且要向共享存储器发送无效信息。最终，只有处理器P的私有Cache中的数据是正确的，而共享存储器和其它处理器Cache中该数据的副本均被标记为无效。</p>
            </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
</body>
</html>
