<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<STYLE TYPE="text/css">
<!--
BODY {background-image:   url(../../../images/htmls/Slicebg.jpg);
background-position: right bottom;
background-repeat: no-repeat;
background-attachment: fixed;
}
-->
</STYLE>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<link rel="stylesheet" href="../../../css/style.css" type="text/css">
</head>

<body  leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" height="100%" border="0" cellpadding="0" cellspacing="0">
  <tr> 
    <td valign="top" height="20">&nbsp; </td>
  </tr>
  <tr>
    <td valign="top">
      <table width="92%" border="0" align="center" cellpadding="0" cellspacing="0">
        <tr> 
          <td class="text" valign="top"> 
            <p>　　<b>任务调度算法</b><br>
              <br>
              　　任务调度算法的最关键之处是任务的分配策略。常用的调度模式有经理/雇员模式和非集中模式。<br>
              <br>
              　　<b>经理/雇员模式</b> 在此模式中，有一个进程（经理）负责分配任务，每个雇员向经理请求任务，得到任务后执行任务。使用预取方法（以使计算和通信重叠）可以提高效率。这种方案的一种变体是<b>层次经理/雇员模式</b>。在此模式中，雇员被分成不相交的集合，每个集合有一个小经理。雇员们从小经理那里领取任务，小经理从经理处领取任务。经理/雇员模式的缺点是经理进程容易成为系统的瓶颈。<br>
              <br>
              　　<b>非集中模式</b> 它就是无中心管理者的分布式调度法。<br>
              <br>
              　　<b>结束检测</b> 任务调度算法需要一种机制来检测整个问题的计算何时结束。<font color="#000000">否则，空闲的雇员们将永不停止地发出任务请求</font>。在经理/雇员模式中，经理可以判断雇员是否都空闲了。所有的雇员都空闲了就意味着整个问题的计算结束了。在非集中模式中结束检测则比较困难，因为没有一个进程知道全局的情况。<br>
            </p>
            </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
</body>
</html>
