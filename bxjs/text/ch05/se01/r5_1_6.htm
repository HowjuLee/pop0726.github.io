<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<STYLE TYPE="text/css">
<!--
BODY {background-image:   url(../../../images/htmls/Slicebg.jpg);
background-position: right bottom;
background-repeat: no-repeat;
background-attachment: fixed;
}
-->
</STYLE>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset="utf-8"">
<link rel="stylesheet" href="../../../css/style.css" type="text/css">
</head>

<body  leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" height="100%" border="0" cellpadding="0" cellspacing="0">
  <tr> 
    <td valign="top" height="20">&nbsp; </td>
  </tr>
  <tr>
    <td valign="top">
      <table width="92%" border="0" align="center" cellpadding="0" cellspacing="0">
        <tr> 
          <td class="text" valign="top"> 
            <p>　<font color="#000000">　</font>前面的仿真没有考虑到将n个虚拟处理器映射到p个物理处理器（n&gt;p）可能有很多的方法的情形，对不同的映射方法，得到的降低处理器规模的算法的性能也可能会不同。在前面的n个数据的加法中，如果有n个处理器，那么数据分布是很自然的，每个处理器分配一个数据即可；但当有p个处理器（n 
              &gt; p）时，为处理器分配数据就有多种方法。此时，同一个问题的并行运行时间是虚拟处理器到物理处理器的映射的函数，并行算法的性能与粗粒度并行计算机上的数据分布密切相关，最优的选择取决于与硬件有关的某些参数的值（<font color="#CC6633">研究数据分步、性能、并行计算平台的关系是本课的一个重要内容</font>）。<br>
              <br>
              　　一个需要W个基本计算步的算法最多能映射到W个处理器，在这种映射下，每个处理器执行串行算法中的一个计算步，然而，如果使用的处理器不足W个，那么每个处理器要完成的计算任务要多一些，为求解这些子问题，对单个处理器来说，可能有不同的串行算法，而对局部计算时算法的选择会影响到总体的并行计算时间。事实上，局部最优算法的选择可能与处理器的数目有关，这样的例子包括矩阵相乘算法和某些排序算法。<br>
              <br>
              　　因此，从最细粒度的并行算法没有一个通用的方法来得到可以在任意数目的处理器上运行的最优并行算法。而且，基于最细粒度并行算法的并行系统分析可能不能体现某些硬件特性对并行系统的性能的贡献。比如，当传递一个字的消息时，存储转发和虚拟直通的路由方法所用的时间相同，但传递大消息时，虚拟直通通常要比存储转发要快。采用虚拟直通的方法，很多的并行算法在超立方体和网格上性能相当，而采用存储转发时，网格上的算法的性能通常要比超立方体上的性能差得多。基于最细粒度并行算法的分析不能揭示出这些细节。<br>
              <br>
              　　<span class="part">小结</span>：前面的讨论只是想说明，设计一个有效的并行算法不只是设计一个每个处理器一个数据或一个计算的算法。构造最细粒度的并行算法通常都很简单，所以，通常把它当作并行算法设计的第一个步骤。然而，完整的并行算法设计必须考虑数据分布，而且需要包括一个面向任意数目处理器的并行计算机上的实现的描述，所以，我们在设计和分析并行算法的时候，总是把问题规模（输入数据的规模）和处理器的数目作为两个变量分开考虑。<br>
            </p>
            </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
</body>
</html>
