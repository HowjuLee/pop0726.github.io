<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset="utf-8"">
<link rel="stylesheet" href="../../css/style.css" type="text/css">
<style type="text/css">
<!--
.bodybg {
	background-attachment: fixed;
	background-repeat: no-repeat;
	background-position: right bottom;
}
a:link {
	color: #000000;
	text-decoration: none;
}
a:visited {
	color: #000000;
	text-decoration: none;
}
a:active {
	color: #0000CC;
}
a:hover {
	color: #0000CC;
	text-decoration: underline;
}
-->
</style>
</head>

<body class="bodybg" bgcolor="#FFFFFF" background="../../images/htmls/openwin/bg.jpg" text="#000000" leftmargin="0" topmargin="0" rightmargin="0" bottommargin="0" marginwidth="0" marginheight="0" >
<p class="bodybg">&nbsp;</p>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td width="15">&nbsp;</td>
    <td class="text"> 
      <p>1<span class="text"><a name="top"></a>、&nbsp; <strong><a href="#1" class="text">为了使一个串行程序变成并行程序，并使它在一个实际的并行计算机系统上运行，需要那些必要的步骤？</a></strong><br>
        2、&nbsp; <strong><a href="#2">体系结构和并行程序语言对并行算法的设计有什么影响，更进一步的说，分布存储和共享存储的并行程序设计方法有些什么不同？</a></strong></span><br>
        3、&nbsp; <strong><a href="#3">为什么会需要并行计算模型，它在并行系统中处于什么位置？</a></strong><br>
        4、&nbsp; <strong><a href="#4">在建立并行计算模型时，需要考虑哪些因素？</a></strong><br>
        5、&nbsp; <strong><a href="#5">那些因素会影响一个并行算法（并行程序）的性能？怎么衡量它们的影响？</a></strong><br>
        6、&nbsp; <strong><a href="#6">一个消息传递系统需要具有哪些基本的功能？</a></strong><br>
        7、&nbsp; <strong><a href="#7">基于消息传递的程序设计中，当程序的性能出现问题时，通常需要考虑哪些问题？</a></strong><br>
        8、&nbsp;&nbsp; <strong><a href="#8">线程与进程之间有什么不同？</a></strong><br>
        9、&nbsp; <strong><a href="#9">在共享存储的计算机系统上，采用OpenMP与采用MPI究竟有什么不同?</a></strong><br>
        10、 <strong><a href="#10">Fork-Join模型与SPMD模型有什么不同？</a></strong><br>
        11、 <strong><a href="#11">OpenMP程序的调试过程中，通常问题会出现在哪些方面?</a></strong><br>
        <br>
        1、<a name="1"></a>&nbsp; 为了使一个串行程序变成并行程序，并使它在一个实际的并行计算机系统上运行，需要那些必要的步骤？ 
        <br>
        　　通常情况下，将一个串行程序并行化，需要完成下面的四方面的工作：<br>
        　　☆&nbsp; 并行性的识别（并行任务的识别）；<br>
        　　☆&nbsp; 并行任务到处理器的映射；<br>
        　　☆&nbsp; 任务间的通信；<br>
        　　☆&nbsp; 任务间的同步。<br>
        　　这四方面的工作在不同的系统中有不同的表现形式，而且在某些系统中，可能对程序员隐藏某些方面的细节（比如在共享存储的计算机系统中，就不需要考虑处理器间的通信）。<br>
        在并行程序的设计中，并行任务的分解和处理器的映射是两个最为关键的任务，他们通常是决定并行程序性能的关键性因素。<br>
        .........................................................<a href="#top">top↑</a> 
      </p>
      <p>2<a name="2"></a>、&nbsp; <strong></strong>体系结构和并行程序语言对并行算法的设计有什么影响，更进一步的说，分布存储和共享存储的并行程序设计方法有些什么不同？<br>
        　　不同体系结构中，处理器之间有不同的关系，这对并行算法设计的各个环节都会产生影响。体系结构和并行程序语言一起为用户提供了并行算法的设计平台，在这个平台中，算法的设计者（和程序的实现者）所需要考虑的重点可能会有所不同。比如，在分布存储的系统中，算法的设计者可能考虑更多的是如何减少通信，而在共享存储的并行程序设计中，算法的设计者可能更需要注意的是如何减少系统中的同步。<br>
        .........................................................<a href="#top">top↑</a> 
      </p>
      <p>3<a name="3"></a>、&nbsp; <strong></strong>为什么会需要并行计算模型，它在并行系统中处于什么位置？<br>
        　　并行计算模型为并行计算提供了软件和硬件的基本界面，这使得硬件的设计和软件的开发成为可能，在此基础上，才能实现并行计算。他和并行系统中的其他模型的关系如下图所示：<br>
        <center>
          <img src="../../images/htmls/openwin/007.gif" width="130" height="220"> 
          <br>
        </center>
        　　正式由于并行计算模型的存在，才使得并行算法的设计和分析成为可能。<br>
        .........................................................<a href="#top">top↑</a> 
      </p>
      <p>4<a name="4"></a>、&nbsp; <strong></strong>在建立并行计算模型时，需要考虑哪些因素？<br>
        　　一般来说，两个基本原则：<br>
        　　☆&nbsp; 对用户应是简单好用<br>
        　　☆&nbsp; 能正确反映体系结构特征<br>
        　　一个并行计算模型应该可以反映体系结构中本质的特点，使得采用这种模型进行程序设计出来的程序在给定的体系结构中能得到预期的性能，也就是说，这个模型应该具有足够多的系统参数；同时，这种模型应该尽量简单明了，它不应该提供那些非必要的细节，这样才能尽量简化程序的设计和分析过程。<br>
        .........................................................<a href="#top">top↑</a> 
      </p>
      <p>5<a name="5"></a>、&nbsp; <strong></strong>那些因素会影响一个并行算法（并行程序）的性能？怎么衡量它们的影响？<br>
        　　一个并行程序的性能通常情况下由下面三个方面决定：一个计算机的体系结构；二是所有的并行计算语言；三是并行程序本身的特性。<br>
        　　他们对一个并行程序的性能的影响可以用并行计算性能分析模型来进行分析。通常情况下，需要得出各部分的额外开销的分布函数，然后在此基础上可以进行相关的可扩展性分析等。同时，也可以根据分析的结果来得到可能的改进方案。<br>
        .........................................................<a href="#top">top↑</a> 
      </p>
      <p>6<a name="6"></a>、&nbsp; <strong></strong>一个消息传递系统需要具有哪些基本的功能？<br>
        　　事实上，一个典型的消息通信库只需要提供四个函数接口：得到系统中进程数；得到本进程的进程好；发送消息；接收消息。<br>
        　　前两个函数是编写SPMD程序的基本要求：它们被用来进行任务分配。<br>
        　　后两个函数是消息传递系统必须提供的基本功能。<br>
        　　在MPI中，除了这四个函数外，程序中还必须具有的两个函数是系统的初始化和程序的终止。<br>
        .........................................................<a href="#top">top↑</a> 
      </p>
      <p>7<a name="7"></a>、&nbsp; <strong></strong>基于消息传递的程序设计中，当程序的性能出现问题时，通常需要考虑哪些问题？<br>
        　　基本上，基于消息传递的程序的性能问题出现在两个方面：第一是并行性开发不够，第二是程序的局部性不好。<br>
        　　并行性开发不够是指程序中主要的部分没有被并行化，或者开发出来的并行性不足以满足所有处理器的执行需求。这时需要考虑识别出程序中的主要未并行部分加以改进。<br>
        　　局部性不好是指程序中任务间的通信过于频繁，这时可以考虑改变数据分布策略和采用通信优化的方法。<br>
        .........................................................<a href="#top">top↑</a> 
      </p>
      <p>8<a name="8"></a>、&nbsp; <strong></strong>线程与进程之间有什么不同？<br>
        　　在很多操作系统中，线程通常被称为轻量级进程（LWP，light Weight Process），和进程相比，它没有自己独立的地址空间，而是存在于进程的内部，由一个（或多个）线程来共享进程的某些资源（比如说环境变量，打开文件等等）。<br>
        　　一个进程内部的多个线程共享进程的全局变量，同时，线程也可以有自己的局部变量。<br>
        　　一个线程有自己的程序计数器（这就是线程这个词的含义：Thread of control）和堆栈。<br>
        　　线程通常以库函数（用户级线程）或者操作系统服务（内核级线程）的方式提供给用户。现在通常使用的线程标准是1995年通过的Posix.1线程标准（称为Pthread）。<br>
        　　线程通常比进程具有较小的创建和管理开销。<br>
        　　进程内部多线程可以通过全局变量实现线程通信（这也是线程通信的主要形式），但同时，由于共享的存在，线程间的同步比进程要更为复杂一些。<br>
        .........................................................<a href="#top">top↑</a> 
      </p>
      <p>9<a name="9"></a>、&nbsp; <strong></strong>在共享存储的计算机系统上，采用OpenMP与采用MPI究竟有什么不同?<br>
        　　OpenMP是基于多线程的计算模型，因此，当你分配计算任务给四个处理器时，系统中产生的是四个线程（它们存在于一个单独的进程中），而MPI产生的是四个进程。由于线程存在于一个共同的地址空间中，所以计算任务之间的通信（比如数据的传递）是隐式进行的（为保证正确性，通常还需要使用同步语句）；而MPI程序的通信即使在共享存储的计算机系统中也必须显式的进行（注意，同步语句在必要的时候也必须存在），具体的通信方式可以采用标准网络通信协议，也可以采用共享存储系统中提供的共享内存这样的机制。<br>
        　　隐式通信指的是程序员在程序中不需要明确的给出通信的语句，而显式通信则需要明确的给出这些语句，因此，OpenMP比MPI程序的编写上要简单的多。<br>
        .........................................................<a href="#top">top↑</a> 
      </p>
      <p>10<a name="10"></a>、&nbsp; <strong></strong>Fork-Join模型与SPMD模型有什么不同？<br>
        　　Fork-Join模型是OpenMP采用的执行模型，而SPMD模型是典型的MPI程序模型。<br>
        　　在Fork-Join模型中，程序分为串行段和并行段，在串行段中，程序中只有一个线程运行，当程序运行到并行段，系统产生多个工作线程共同工作，并行段结束时，这些工作线程也同时结束。<br>
        　　在SPMD模型中，在程序开始阶段就产生多个进程（这些进程执行相同的程序），这些进程到程序结束时才会终止。程序中也可以划分出串行段和并行段，只是在串行段时，各进程或者等待一个进程执行，或者各进程都执行相同的代码。可以参见下面的图：<br>
        <center>
          <img src="../../images/htmls/openwin/008.gif" width="383" height="286"> 
        </center>
        <br>
        　　Fork-Join模型具有简单而清晰的程序结构，因此，采用这个模型的程序结构性更好，而采用SPMD模型的程序由于没有过多的线程（进程）的产生和结束的开销，因此，具有更高的效率。<br>
        .........................................................<a href="#top">top↑</a> 
      </p>
      <p>11<a name="11"></a>、&nbsp; <strong></strong>OpenMP程序的调试过程中，通常问题会出现在哪些方面?<br>
        　　在OpenMP程序中，通常情况下，语法错误可以很容易的发现，但由于低层采用的是多线程的机制，很容易产生Race Condition这样的现象，也就是说，程序的运行结果依赖程序的实际执行过程中各线程的执行次序。这通常是因为程序中变量属性没有设置正确的结果。<br>
        　　OpenMP标准中最复杂的部分就是变量属性的说明，在通常情况下，应该尽量减少全局变量的使用（对全局变量的使用应该加锁）。<br>
        　　如果性能方面出现了问题，应该检查程序中主要的计算部分是不是已经并行化，循环的调度方式是否恰当。<br>
        .........................................................<a href="#top">top↑</a> 
        <br>
      </p>
      <br>
    </td>
    <td width="15">&nbsp;</td>
  </tr>
</table>
</body>
</html>
