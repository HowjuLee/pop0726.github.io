<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset="utf-8"">
<link href="../../../css/weiji.css" rel="stylesheet" type="text/css">
</head>

<body bgcolor="#FFF3C4">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td class="pt9">　　为了解决上述问题，Pentium使用了写一次政策。当处理器的内部写第一次命中某一个L1 Cache行时，数据被装入这一行并将它标记为共享状态。并且规定这次写操作为写直达，同时写到L2的对应行。L2 
      Cache检查他的目录发现目标行的副本，于是L2更新数据并将这一行标记为修改状态。这样L2就能够正确地进行监听并阻止任何总线主读取存储器相应行中的过时数据。完成写直达以后L2 
      Cache指示L1将这一行的状态从共享改为独占。表示没有其他总线主的Cache子系统和它共享数据。随后，当执行单元再一次写这一行，L1查找目录再次命中，发生在这一行的第二次和其后的写操作，都按照写回策略进行。新数据装入L1的行，状态标志由独占改为修改，表示写直达完成以后这一行数据已经被修改了，这次写操作没有传播到L2。目前，这行在L1 
      Cache的数据是比在L2中更新的版本。这种对第一次命中的内部Cache行仅仅执行一回写直达，之后的写全都按照写回规则进行的策略为写一次策略。<br>
      　　这时候，如果另一个总线主企图读取同一行存在存储器中的数据时，L2 Cache就会监听这个地址并且会发现命中了一个修改状态的行。因此，在将最新版本的数据装入这个存储器行以前L2将阻止另一总线主对存储器的读取。L2首先把监听地址传给L1 
      Cache，L1就会监听这个地址以确定是否内部Cache的这一行包含了比L2版本更新的数据。在本例中，L1 Cache确定这一行包含了修改过的数据，于是L1 
      Cache执行一次写回操作把最新的数据写入存储器相应行中以便另一个总线主的读取。完成写回后，L1 和L2 Cache以及存储器内的这个相关行便存储了同样的信息。L2撤消阻止信号准许总线主从存储器读取最新数据，并把L2中这一行的状态从修改态改为共享态，表示其他总线主也拥有这行数据的备份。另外，L2指示L1把该行状态由修改态改为共享态。<br>
    </td>
  </tr>
</table>
</body>
</html>
