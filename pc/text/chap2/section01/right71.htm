<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset="utf-8"">
<link href="../../../css/weiji.css" rel="stylesheet" type="text/css">
<link href="../../../css/weiji.css" rel="stylesheet" type="text/css">
</head>

<body class="bg">
<table width="100%" border="0" cellspacing="2" cellpadding="1">
  <tr> 
    <td class="pt9"><br>
      　　　　表2-9：中断优先级<br>
      <img src="../../../images/chap2/p2_1_5_4.gif" width="365" height="86"><br>
      <object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="../../../../../../../../download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,29,0" width="420" height="570">
        <param name="movie" value="../../../flash/2_14.swf">
        <param name="quality" value="high">
        <embed src="../../../flash/2_14.swf"  quality="high" pluginspage="http://www.macromedia.com/go/getflashplayer" type="application/x-shockwave-flash" width="420" height="570"></embed></object>
      <br>
      　　请大家仔细分析“图2-26：8086对中断的响应的流程图”，左边部分反映了几个中断同时发生的情况，CPU首先响应的是内部中断、其次是NMI、再其次是INTR、最后是单步中断。<br>
      　　流程图的右边部分则体现了当几个中断不是同时发生时的情况，即当某一中断正在服务时，出现其他中断请求，是否会发生中断嵌套，则取决于中断控制标志的状态，而与中断优先级无关。<br>
      　　当CPU响应中断，进入中断应答周期后，做如下操作：标志寄存器推入堆栈，令TEMP=TF，清除IF、TF，中断入口地址送CS、IP。标志寄存器推入堆栈，是为了保存标志寄存器的原始状态；清除IF、TF，以前说过，将IF清零是为了能够在中断响应过程中暂时屏蔽外部其他中断，以免还没有完成对当前中断的响应过程就又被另一个中断请求打断。将TF标志清零是为了避免单步中断的中断处理程序也以单步的方式执行；但在清除IF、TF之前，有一步令TEMP=TF，目的是清除TF之前保留TF状态，以便在中断服务程序中（单步中断服务程序除外）能响应单步中断。紧跟“中断入口地址送CS、IP”之后，是判断是否有NMI、是否有单步（TEMP=1）如果有则中断当前服务程序，发生NMI或单步的中断嵌套。INTR中断是否能打断当前正在服务的中断程序，发生中断嵌套，则完全取决于IF的状态，进入中断响应周期后IF=0，如果在当前正在服务的中断程序适当位置，　　置IF=1，INTR中断就能被响应了。<br>
      综上所述，所谓中断优先级仅仅指当几类中断同时请求时，CPU首先响应优先级高的中断请求。如果不是同时请求，是否会发生中断嵌套，则完全取决于中断控制标志的状态，而与中断优先级无关。</td>
  </tr>
</table>
</body>
</html>
